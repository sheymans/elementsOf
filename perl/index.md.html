
<meta charset="utf-8">
                            **WIP: Elements of Perl**
                            Stijn Heymans
                            Published: N/A
                            Revised: N/A

# Introduction

TODO: Audience, someone with familiarity with 1, preferably more, programming
languages. This is not a "how to program" course.

# Scalars

## Strings

### Basic Usage

Scalars or scalar values are the smallest unit of data in perl. Numbers and
strings are scalars.

We'll store scalars in variables as follows:

~~~perl
my $var = 'I am a string';
~~~

!!! note
   _statements_ in perl end with `;` as they do in Java or C++.

The `my` keyword _declares_ the variable (similar to a `let` in Javascript),
and `$var` consists of the symbol `$` and the name `var`. The use of symbols
like `$` is something to get used to when switching from python/Javascript to
perl. The symbol `$` hints at how the variable is used or accessed. In this
case, it declares and initializes a string, which is a scalar, and thus the
symbol `$` emphasizes that.

You'll later see a symbol `@` for array usage and `%` for hash usage (a `hash`
is python's `dict` or generally a key-value structure such as a `Map` in Java).

Back to strings. A common operation is concatenating 2 strings:

~~~perl
my $concat = $var . ' and me too.';
~~~

If you'd like to change `$var` by concatenating something to it, instead of
`$var = $var . ' and me too.'` you can do:

~~~perl
$var .= ' and me too.';
~~~

Note the single quotes for strings we used. What about double quotes?. You can
use double quotes as well. Good practice is to use them only when you want to
_interpolate_ variables in them. For example:

~~~perl
my $name = 'stijn';
my $hello = "my name is $name";
~~~

Interpolation makes sure that `$name` in that `$hello` string is always
_expanded_ to its value. In this case, it will be `my name is stijn`.
Interpolation will usually lead to cleaner code than concatenation. Compare the above to:

~~~perl
my $name = 'stijn';
my $hello_conc = 'my name is ' . $name; 
~~~

Why is it good practice to only use them when you actually want to interpolate
variables? Imagine I have 

~~~perl
my $money = "my password is !$guest";
~~~

In this case `perl` will try to expand `$guest` which does not exist and will
result in warning and an unexpected result in `$money`.

You actually meant:

~~~perl
my $money = 'my password is !$guest';
~~~

You can get individual characters of a string as you'd expect from other languages:

~~~perl
my $string = 'what';
my $first = $string[0];
~~~

The kicker is to get the last character of the string using `-1`, something you
might know from `Python`:

~~~perl
my $last = $string[-1];
~~~

### Useful built-in Functions

#### [`print`](https://perldoc.perl.org/functions/print.html)

Printing to `STDOUT` will be mostly useful for debugging the odd statement here and there:

~~~perl
print "This is a printed string\n";
~~~

!!!
   There's an explicit `\n` in that statement; you might be used to a `println`
   from other languages that puts that `\n` there for you. But `perl` is not
   putting it there for you.

#### [`substr`](https://perldoc.perl.org/functions/substr.html)

Extract a substring out of a string. For example, to get a `cat` out of `concatenate`, do:

~~~perl
my $cat = substr('concatenate', 3, 3);
~~~

The first `3` is the offset from where to start the substring, the second `3`
is the length of the substring you want (_cat_ has 3 letters). You'll see this
pattern occur frequently, an _offset_ followed by a _length_ in the arguments
of a function.

If you leave off the length, you'll just take the substring until the end of
the string, for example to get `catenate`:

~~~perl
my $nonsense_substring = substr('concatenate', 3);
~~~

#### [`split`](https://perldoc.perl.org/functions/split.html)

`split` splits a string into parts based on a regular expression
`/REGEXP/`. However, I will just mention the form you'll often spot in the
wild:

~~~perl
split //, 'yeah';
~~~

This will split the string `yeah` into its individual characters because the
pattern `//` matches _everything_ and returns a list of individual characters
(arrays follow later).

!!! 
   Note the `split //, 'yeah'` without parenthesis. Based on
   how I wrote `substr` you expected to see `split(//,'yeah')` and you'd been
   right as well! `perl` is playing loose with parenthesis generally, so for
   built-in functions you'll often see parenthesis dropped. For functions you
   write yourself, I suggest to keep parenthesis when invoking them. Life is
   complicated enough as it is.


## Numbers

### Basic Usage

Let's dive into numbers.

~~~perl
my $numero = 42;
~~~

Easy enough. We can add numbers:

~~~perl
my $sum = $numero + 42;
~~~

which is of course the same as if we would have done:

~~~perl
my $doubling = 2 * $numero;
~~~

Similar like in other languages, there is a short hand for `$numero = $numero + 42`:

~~~perl
$numero += 42;
~~~

and _pour les_ for other operations _la mÃªme chose_.

### Useful built-in Functions

I guess this is where I'd give a `sqrt` example, but how often have you used a
`sqrt` function in your professional code?

Oh, you can `print` numbers and a good conversion (the `%d` in the below template string) is...`%d`:

~~~perl
print "The meaning of life is %d", 42;
~~~

## `undef`

I talked about scalars like strings and numbers. But what about `null`? `null`
is a _thing_! Does `perl` have a `null`? Yes: `undef`. And where you'll see
in other languages a lot of null-checks, in `perl`, you'll see a lot of:

~~~perl
if (defined $x) {
  # stuff
}
~~~

which checks whether `$x` is defined (so is `$x` `undef` or not).

What's with the 

~~~perl
# stuff
~~~

You guessed it. `#` marks comments: anything
following it is ignored by the `perl` compiler.

# Array Variables

## Basic Usage

I get headaches when people start about an _array_ is this but a _list_ is
this. This is how you create an array of elements `I`, `do`, `not`, `care`:

~~~perl
my @array = ('I', 'do', 'not', 'care');
~~~

Note the `@` symbol prefixing the variable name. In contrast to
other languages like Python or Javascript, `perl` gives you a hint on what
kind of variable something is. We already saw _scalar_ variables in which you
can store the smallest unit of _things_. The `@` signifies this is an _array_
variable and stores a _list of things_. And the wording of _things_ is
intentional. Array variables store lists of _things_. So if a list contains the
variable, that variable will be a _scalar variable_.

I have find this probably the most confusing _thing_ (so I'd store my confusion
in a scalar).

Let's complicate this slightly more. Try getting the first element of the array `@array`:

~~~perl
my $first_element = $array[0];
~~~

The `[0]` part should look familiar, but note that it is `$array` when you use
`@array` to _access_ the scalar value at the first position (index `0`).

The last element is usually easily retrieved using the `-1` index:

~~~perl
my $last_element = $array[-1];
~~~

We can change an element similarly as retrieving. Change the first element of `@array`:

~~~perl
$array[0] = 'You';
~~~

I can copy an existing array `@array` to a new array `@copy`:

~~~perl
my @copy = @array;
~~~

Note that here I again use `@` for both: I'm creating an array `@copy` and
copying the array `@array` (I am not referring to the individual elements in
`@array`: the array is used in a _list_ context).

Note that this is indeed a copy: changing elements in `@copy` will _not_ change
elements in `@array`.

## Useful built-in Functions

### Adding and Removing from Back of an Array


You can remove elements from the back/end of an array, using [`pop`](https://perldoc.perl.org/functions/pop.html):

~~~perl
my @array = (4, 5);
my $last = pop @array;
~~~

Note that we did not write `pop(@array)` as `pop` is a built-in. We leave
parenthesis of of built-ins per convention. What will `$last` store? It'll
store the last element of `@array`: `5`. What will `@array` store after the
`pop`ping? An array with the last element removed: `(4)`.

You can add it back by adding it to the end of array using [`push`](https://perldoc.perl.org/functions/pop.html):

~~~perl
push @array, 5;
~~~

Then, `@array` will be `(4, 5)` again. You can also use `push` to append a list:

~~~perl
push @array, (4, 5);
~~~

### Adding and Removing from Front of an Array

Sometimes you'd want to add something to the front of an array, and we use the
very memorable [`unshift`](https://perldoc.perl.org/functions/unshift.html)
for that:

~~~perl
unshift @array, 4;
~~~

This adds `4` to the front of `@array`. Note that you can also pre-pend lists like that:

~~~perl
unshift @array, (4, 5)
~~~

This would turn an `@array` that is `(6, 7)` into `(4, 5, 6, 7)`. Note that the order is
preserved (so it does not loop through `(4, 5)` and adds the elements one by
one)

Similar to how `pop` removes from the back of the list, we have a function to remove something from the start of the list:

~~~perl
my $first = shift @array;
~~~

`@array` will be modified after this: the first element is removed and in this
case we stored it in `$first`. You can imagine
[`shift`](https://perldoc.perl.org/functions/shift.html) as shifting the array
to the _left_ and thus dropping of the first element.

### Length of an Array with a detour to contexts

The length of an array is a funny thing. The notion of _context_ (briefly
mentioned before) is important in `perl`. For example, assigning an array to a
scalar variable, will cause the _length_ of that array to be assigned to the
scalar. Indeed, you cannot store an array into a scalar, so what do you store?
Well, a reasonable thing to store is the length of that array. So for this:

~~~perl
my @array = ('hey', 'you');
my $scalar_something = @array;
~~~

we have that `$scalar_something` now contains `2`: the length of `@array`. 

This also works the other way: what if you want to store a scalar into a list?
For example:

~~~perl
my $scalar = 'a';
my @array = $scalar;
~~~

You're now trying to store a scalar variable `$scalar` into an array variable,
or in other words, into a _list context_. `perl` will try to make a list out of
the scalar, and the natural way to do so is by treating your scalar as a list
with 1 element in it (the scalar). So `@array` will effectively be the list
`('a')`.


### [`reverse`](https://perldoc.perl.org/functions/reverse.html)

We can reverse arrays as follows:

~~~perl
my @array = (1, 2);
my @rev = reverse @array;
~~~

`@rev` will be `(2, 1)` and `@array` will have stayed the same (so `reverse` is
non-destructive on its argument).


# Hash Variables

## Basic Usage

Some variation of a key/value data structure (or `Map`, or `dict`) is common.
In `perl` they are called a _hash_. A hash _literal_ can be initialized as
follows:

~~~perl
my %some_hash = ('name', 'john', 'age', 39);
~~~

There are a couple of interesting things going on here:

1. we used a new symbol `%` for indicating that `some_hash` is a variable used to store a hash. 
2. there seems to be no distinction made in syntax between keys and values. We'd expect `'name'` and `'age'` to be keys, and `'john'` and `39` to be values. Instead, this has the same syntax as a literal list. In fact, it _is_ just a list. Let's get back to our _contexts_. We already saw a _list context_ and a _scalar context_. The `%` on the left-hand side of the assignment, indicates a _hash context_ and whereas the right-hand side is indeed a list, we are trying to assign the list to a hash such that effectively we indeed store a hash (i.e, something we can access based on keys `'name'` and `'age'` as we will see in a bit.
3. The keys `'name'` and `'age'` are strings while the values is a string or a number (`39`). Indeed, the keys of a hash are always strings. The values are less strict and can be any _scalar_. As such we cannot nest hashes by embedding another hash as a value within a hash. At least not without a final concept called _references_ which we'll introduce later. For now, remember that values of a hash are always scalars.

As the list syntax for hashes is obviously confusing, `perl` has a trick (of
course it has). We can replace certain commands by so-called `fat commas`: `=>`.
A fat comma `=>` is absolutely the same as a comma for the perl parser, but for
us mere humans, it makes things a bit more palatable:

~~~perl
my %some_hash = ('name' => 'john', 'age' => 39);
~~~

When using the fat arrow notation, you can also leave of the quotes on the keys:

~~~perl
my %some_hash = (name => 'john', age => 39);
~~~

We can access values of a hash, using curly braces (`{` `}`):

~~~perl
my $name = $some_hash{name};
my $age = $some_hash{age};
~~~

Note that I did not write `'name'` nor `'age'`: indeed once `%some_hash` is
establishes as a hash, you can access values by using the keys without quotes
whether you initialized with quotes keys or not. However, you _could_ have written:

~~~perl
my $name = $some_hash{'name'};
my $age = $some_hash{'age'};
~~~

Same difference. We also used the scalar `$` symbol instead of the hash symbol
`%` when _accessing_ the hash. In effect, we're accessing a scalar so we use
`$`. Or differently, `$some_hash{name}` _is_ a scalar (always, but the rule
that values in hashes have to be scalars) rather than a _hash_, so it makes
sense to refer to it with `$`.

Changing the value for a key is than as you'd expect:

~~~perl
$some_hash{name} = 'bill';
$some_hash{age} = 40;
~~~

## Useful built-in Functions

### `values`/`keys`

As is usual with map-like structures in programming languages, you can get the
keys `age` and `name` from the hash:

~~~perl
my @keys = keys %some_hash
~~~

Indeed, `@keys` will be the array `('age', 'name')`. Similarly, you can get the
values `39` and `john` from the hash:

~~~perl
my @values = values %some_hash
~~~

Indeed `@values` will be the array `(39, 'john')`. Note that even though we
defined `%some_hash` using the literal `('name', 'john', 'age', '39')` which
hints at some _ordering_, neither `values` nor `keys` need to satisfy that
original order. 

# References

_References_ or the concept that makes nested structures possible. Recall that
arrays can store lists of scalars and hashes are key-value maps where the key
needs to be a string and the value needs to be a scalar.

At first sight this restricts us to rather flat data structures, for example, I
could not directly store a list of hashes. Or a hash that is an index of names
(the key) to person's addresses (the value, consisting of street, zip code)).

But of course, we can, but we need a new concept for it: the _reference_. To
some degree the reference is a bit like C/C++ style pointers. It is officially
a _scalar_ that _points_ to other _things_ (and those other other things could
be other lists, hashes, or other scalars, and thus also other references).

For example, say we have a reference `$a_ref` (note that references are
scalars, so here we go with the `$` again) that points to an array `(1, 2, 3)`:

***********************************
*                                 *
*   .--------.       .----------. *    
*   | $a_ref +----->| (1, 2, 3)  |*
*   '--------'       '----------' *
***********************************

This now means that we can indeed have a hash with values that are effectively pointing to arrays:

~~~perl
my $array_value_hash = ('john': $a_ref);
~~~

I kept a crucial piece to myself though. How did I create that `$a_ref`
reference to the array `(1, 2, 3)`? Recall that we would create an array
variable as follows:

~~~perl
my @array = (1, 2, 3);
~~~

I can now take a reference to `@array` using `\`:

~~~perl
my $a_ref = \@array;
~~~

There's a shorthand for taking a reference to an array _literal_ though:

~~~perl
my $a_ref = [1, 2, 3];
~~~

So use square brackets `[ ]` instead of `( )`. Effectively, this:

~~~perl
my @array = (1, 2, 3);
my $a_ref = \@array;
~~~

is the same as:

~~~perl
my $a_ref = [1, 2, 3];
~~~

How could I now get values out of that array, given the reference `$a_ref`
rather than using the `@array`. Well, recall that you could get the first
element (or change the first element) of `@array`, doing `$array[0]`. We can
get to the underlying array based on the `$a_ref` reference, by
_de-referencing_ it (pointers anyone?) using curly brackets `{$a_ref}`. Getting
the first element based on `$a_ref` can then be done by:

~~~perl
my $first = ${$a_ref}[0];
~~~

Similar rule dereferencing rule holds in situations where you'd normally deal with the array itself like when copying:

~~~perl
my @copy = @array;
~~~

To make a copy based on the `$a_ref`, you could do:

~~~perl
my @copy = @{$a_ref};
~~~

You can see that we just switched out the `array` part in `@array` by the
dereferenced `{$a_ref}` reference: `@{$a_ref}`.

TODO: change value of original array when having the copy be a copy of the array reference.

TODO: shorthands for ${$} ($$ and `->`).

TODO: references to hashes.







# Conditions

`if`, `grep`, and `any`, and `first`.

# Looping

## With `for`

## With `map`

# Subroutines

TODO: talk about call by value for functions (can I change arguments: yes, if I use references)

TODO: talk about why you will see `my $first = shift` without arguments for shift (cause it uses `@_` by default).o

TODO: coderefs or subroutine references

# Regular Expressions

We cannot talk about `perl` without regular expressions.

# Constants

I know you miss your `private static final` variables, my dear `java`
aficionado. For the rest of the world, constants, how do I declare something as
constant, you can't change it, don't touch it, don't even look at it!?


# Examples

# More

We skipped objects and so much more.

# Conclusion


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
