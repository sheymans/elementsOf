<meta charset="utf-8">
                            **Elements of OAuth 2.0**
                            Stijn Heymans

# Introduction

In this article, I try to given an intuition of what the OAuth 2.0 flow is and
what problems it solves. This is not intended to be a detailed overview of
OAuth 2 and as such is just the tip of the iceberg. My hope is that this give
you a good intuition of the _why_ leaving other parts intentionaly vague and
conceptual. I gained most of my intuition from the book [OAuth 2 in
Action](https://www.goodreads.com/book/show/30102872-oauth-2-in-action) which
has great code-along examples if you want to see the OAuth 2 flow at work.

A final note, before diving in: even though I use examples like _Bank Of
America_ or _mint_, I use them for illustration purposes. These companies will
be doing things differently as they operate in the _real world_. A concept I'm
not directly bothered with.

# The User Accesses A Resource Directly

You keep neat budgets, so you decide you want to check your transactions at
[Bank of America](https://bankofamerica.com). You open up your favorite browser
and you go to said site. You click _Sign-in_ and are presented with the
classical login form:

![Classical Login](./images/classic_login.png)

You faithfully enter your username and password and get to see all your
transactions of the past month. Both Whole Foods and Amazon got too much money
from you this month, again.

![Simple OAuth](./images/simple_auth.png)

We'll your username/login combo, your _credentials_ and add to that:

!!! Tip
    OAuth 2 is not about credentials.

This example also sets the stage for identifying you (aka the human) with your
browser (your _user-agent_), we'll refer to you and your browser as one (at
this point in history, a fair assumption) and name you/your browser, the
_User_.

We will call _Bank of America_, the _Resource Owner_: they own your
transactions (the resource).


![Simple OAuth](./images/simple_auth2.png)


# The User Does not access the Resource Directly

If you do not access the resource directly, for example, you are using a
budgetting tool like [mint](mint.com) that pulls the Bank of America
transaction data for you and shows it to you nicely categorized by budget.
In this case, clearly [mint](mint.com) somehow needs access to the _Resource
Owner_ on behalf of you the _User_.

The first approach that comes to mind is, well, let [mint](mint.com) ask you
for your credentials and pass them through to Bank of America whenever you it
needs Bank of America transaction data:

![Mint First Version](./images/mint_first_version.png)

We'll usually call something like [mint](mint.com) the _Client_, so that the
general scheme looks like this:

![Mint First Version Abstracted](./images/mint_first_version_abstracted.png)

Of course, [mint](mint.com) having to ask you each time to give your
credentials is terribly annoying for you, the _User_. So [mint](mint.com) might
be tempted to think _we'll ask you once, and then we'll store it so we don't
have to ask you again_.

The flow looks exactly like above, except that now [mint](mint.com) asks you
for credentials once and then stops asking you.

What are the problems with this approach?

- _clients store your credentials_. If [mint](mint.com) gets compromised and your credentials get stolen, someone else now can access your Bank Of America account as if they were you.  You have the same problem with if Bank of America itself gets compromised of course, but this increased your risk with a factor of 2 (from 1 place that has your credentials, to 2 places that have your credentials). Imagine, you're using other clients than [mint](mint.com) to access your data. That's a third place that can get compromised.

- _anyone with your credentials has the same access you have_. Depending on what you can do as a user, someone having your credentials can do exactly what you can do. 

# OAuth 2.0

The above leads us to wanting to rethink this and find a way to give clients
appropriate access to resources you own -- giving [mint](mint.com) access to
Bank of America without that they store your credentials. If those get stolen
they'd give the thief the same access to the resource as they were you and this
until you go and change your credentials at the resource (Bank of America). In
addition, we want to make sure that clients only have the access that you
deemed appropriate (for example,  [mint](mint.com) should only be allowed to
read your transaction data but not change it).

Let's try to find solutions for a client ( [mint](mint.com) ) needing access
on your behalf without that they need to store your credentials nor ask you all
the time for your credentials. The _on behalf_ part in that sentence is why
OAuth 2.0 is considered a _delegation_ protocol rather than an authorization
protocol (so far for naming things).

## The Players

We already identified 3 players in the OAuth 2.0 delegation:

- the User (you, or a proxy for you, for example your browser)
- the Client (the application your interacting with, for example [mint](mint.com))
- the Resource Owner (the place that is the origin of your data, for example Bank Of America).

OAuth 2.0 introduces a 4th player that takes care of the actual authorization:

- the Authorization Server.

In our running example, we'll assume the authorization server is owned by Bank
Of America which makes sense as they'd be able to check your credentials which
is stored on some of their systems to be able to give you access).

## The Dance

Let's follow the following thought: Bank of America clearly knows how to
identify your credentials, so could the client mint redirect you to Bank of
America's authorization server, have the authorization server verify your
credentials and then send the client a _sign_ indicating _yes, you can give
that user access to this transaction data_.

What would this require?

- the client (mint) would need to be able to send you, the user (or your browser) over to Bank of America's authorization server
- the authorization server would verify your credentials and would need to conclude _yes, you have access_
- the authorization server would have to tell the client _that particular user has access and you can come pull the data from the Resource Owner_.
- the client would use that authorization and go the resource owner and ask it to give the client the user's data

We could accomplish the above as follows:

- sending the browser of to the authorization server can happen using HTTP redirects (code 301). The user wants to access the data from the client, but the client instead sends the user's browser a redirect to the authorization server. The browser subsequently follows that redirect and lands at the authorization server.
- the authorization server can then start a flow with the user's browser to enter the user's credentials and would subsequently check the user's credentials
- the authorization server can tell the client that the user's credentials are OK by similarly redirecting the user's browser back to the client by including in the redirect URL something called an _access token_.
- the client would then use that _access token_ (which it keeps associated with the user) to go and ask the Resource Owner for the user's data. Since the Resource Owner is presumably able to interpret the access token (both the Resource Owner as well as the Authorization Server are Bank of America, so when the authorization server creates a token for the user's the resource owner would be able to verify that the access token is indeed valid).

We'd have something like this:

![Mint with Access Token](./images/access_token_only_mint.png)

Or abstractly:

![Flow with Access Token](./images/access_token_only_abstract.png)


Let's see how this solves the original problems:

- The client indeed no longer stores your credentials. The client would store the access token. How is that different from storing credentials?  The access token that has been provided by the authorization server is unique for the client. Thus, when your access token is stolen from the client and used by someone else, the resource owner can verify that the access token is not belong to the right client. Furthermore, once access tokens are stolen, the resource owner could disable all access tokens for the client and ask all users to authenticate again. A client being compromised would not affect you, the User, to get data from the resource owner directly (i.e., by logging into Bank of America directly).

- Someone with the access token does not have the same privileges you as the user have directly with the resource owner. We left that out of the above discussion but clients would redirect you to the authorization server specifically asking for a certain _scope_ of access (read-only to certain parts of your data etc). So even if someone can use your access token, they would be able to do only what the scope for that access token allows them to do (which would presumably for example not be to transfer money or change your original credentials at Bank of America, but just use your transaction data, which is bad, but not as bad as having the full access you as a user have).

That was not too complicated. However, there is one problem with this access
token flow. Can you spot it?

Let's zoom in on the interaction between you, mint, and the Bank of America authorization server:


![Frontend channel](./images/access_token_only_mint_zoom.png)

As we explained above, this interaction happens mostly via HTTP redirects over your browser:

- the authorization server sends your browser a redirect with the access token in the url or body
- the browser hits mint with that access token in the url where mint stores it and uses it to gain access to the resource (Bank of America)

The problematic part here is the _browser_. This part of the communcation, the
back-and-forth using redirects is called the _front-channel_ communication and
since it goes via your browser it is vulnerable to having the access token
intercepted. The _back-channel_ communication (for example from mint to the
resource owner) is much more secure in that respect; there is no user browser
involved, just service to service communication.

The way OAuth 2.0 deals with this is to have the authorization server not redirect you to the client with the magical access token, but with an authorization tokenn:

![The OAuth 2.0 Dancel](./images/authorization_token_abstract.png)

So now the front-channel no longer sees the access token. It does see the
authorization token though. What if that authorization token gets stolen? Can
the thief access our data at the _Resource Owner_ with that information?

The authorization token does not give you access to the data at the _Resource
Owner_ as the _Resource Owner_ needs an access token. Can the thief get an
access token from the _AuthorizationServer_ given the authorization token?

The getting of the access token happens on the back-channel from the _Client_
to the _Authorization Server_ and as such can be protected (no _User_ involved)
for example by requiring the _Client_ to send a _client id_ and _client secret_
for example which the _Authorization Server_ can verify.


# Conclusion

We showed the different problems one has when delegating your user credentials to a client directly:

- clients store your credentials
- someone with your credentials has the same access you have

We gradually introduce the OAuth 2.0 flow (_The Dance_) that solves these
problems, including an intuition on the difference between front-channel and
back-channel communcation as well as why we need the authorization flow as well
as the access token (and not just the access token).

In order to convey that basic intuition (the _why_ of OAuth 2.0) we left out
many parts of this story such as the different authorization code grants, the
particular format of access tokens, what refresh tokens are and where they come
into play.  If you're interested in learning more check out [OAuth 2 in
Action](https://www.goodreads.com/book/show/30102872-oauth-2-in-action) or,
better, implement OAuth 2.0 yourself to secure your service.


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12447521-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }

  gtag('js', new Date());

  gtag('config', 'UA-12447521-1');
</script>

<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

