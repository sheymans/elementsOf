
<meta charset="utf-8">
                            **WIP: Elements of Perl**
                            Stijn Heymans
                            Published: N/A
                            Revised: N/A

# Introduction

# Scalars

## Strings

### Basic Usage

Scalars or scalar values are typically the smallest unit of data type in perl, for example numbers and strings.

Generally, we'll store scalars in variables as follows:

~~~perl
my $var = 'I am a string';
~~~

The `my` in this part _declares_ the variable (similar to a `let` in
Javascript), and `$var` consists of the symbol `$` and the name `var`. The
latter is one of the things to get used to when switching from
python/javascript to perl, the symbol `$` hints at how the variable is used or accessed. In
this case, it declares and initializes a string, which is a scalar, and thus
the symbol `$` emphasizes that.

You'll later see symbols `@` for array usage and `%` for hash usage (a `hash`
is python's `dict` or generally a key-value structure such as a `Map` in Java).

Back to strings, you'll from to time want to concatenate 2 strings:

~~~perl
my $concat = $var . ' and me too.';
~~~

!!! note
   _statements_ in perl end with `;` as they do in Java or C++.


If you'd like to change `$var` by concatenating something to it, instead of `$var = $var . ' and me too.'` you can do:

~~~perl
$var .= ' and me too.';
~~~

You have spotted the single quotes for strings, and are wondering _what about
double quotes?_. You can use double quotes as well. Good practice is them only
when you want to _interpolate_ variables in them. For example:

~~~perl
my $name = 'stijn';
~~~

Interpolation will now make sure that `$name` in that `$hello` string is always
_expanded_ to its value. In this case, it will be `my name is stijn`.
Interpolation will usually lead to cleaner code than concatenation:

~~~perl
my $name = 'stijn';
my $hello = "my name is $name";
my $hello_conc = "my name is " . $name; 
~~~

Why is it good practice to only use them when you actually want to interpolate
variables? Imagine I have 

~~~perl
my $money = "my password is !$guest";
~~~

In this case `perl` will try to expand `$guest` which does not exist and will
result in warning and an unexpected result in `$money`.

You actually meant:

~~~perl
my $money = 'my password is !$guest';
~~~

You can get to individual characters of a string, as is expected from other languages:

~~~perl
my $string = 'what';
my $first = $string[0];
~~~

The kicker is to get the last character of the string:

~~~perl
my $last = $string[-1];
~~~

### Useful built-in Functions

#### [`substr`](https://perldoc.perl.org/functions/substr.html)

Extract a substring out of a string. For example, to get a `cat` out of `concatenate`, do:

~~~perl
my $cat = substr('concatenate', 3, 3);
~~~

The first `3` is the offset from where to start the substring, the second `3`
is the length of the substring you want (_cat_ has 3 letters). You'll see this
pattern occur frequently, an _offset_ followed by a _length_ in the arguments
of a function.

If you leave off the length, you'll just take the substring until the end of
the string, for example to get `catenate`:

~~~perl
my $nonsense_substring = substr('concatenate', 3);
~~~

#### [`split`](https://perldoc.perl.org/functions/split.html)

Generally, allows to split a string into parts based on a regular expression
`/REGEXP/`. However, I will just mention the form you'll often spot in the
wild:

~~~perl
split //, 'yeah';
~~~

This will split the string `yeah` into its individual characters because the
pattern `//` matches _everything_ and returns a list of individual charactesr
(arrays follow later).

!!! 
   You'll have spotted `split //, 'yeah'` written without parenthesis. Based on
   how I wrote `substr` you expected to see `split(//,'yeah')` and you'd been
   right as well! `perl` is playing loose with parenthesis generally, so for
   built-in functions you'll often see parenthesis dropped. For functions you
   write yourself, I suggest to keep parenthesis when invoking them. Life is
   complicated enough as it is.


## Numbers

### Basic Usage

Let's dive into numbers.

~~~perl
my $numero = 42;
~~~

Easy enough. We can add numbers:

~~~perl
my $sum = $numero + 42;
~~~

which is of course the same as if we would have done:

~~~perl
my $doubling = 2 * $numero;
~~~

Similar like in other languages, there is a short hand for `$numero = $numero + 42`:

~~~perl
$numero += 42;
~~~

and similarly for other operations.

### Useful built-in Functions

I guess this is where I'd give a `sqrt` example, but how often have you used a
`sqrt` function in your professional code?

Oh, you can `print` them and a good conversion (the `%d` in the below template string) is...`%d`:

~~~perl
print "The meaning of life is %d", 42;
~~~

# Array Variables

### Basic Usage

I get headaches when people start about an _array_ is this but a _list_ is this. This is how you create an array of elements `I`, `do`, `not`, `care`:

~~~perl
my $array = ('I', 'do', 'not', 'care');
~~~

### Useful built-in Functions

- TODO: mix array and scalar operations (e.g., with lenght)

# Hash Variables

# References

# Conditions

`if`, `grep`, and `any`, and `first`.

# Looping

## With `for`

## With `map`

# Subroutines

# Regular Expressions

We cannot talk about `perl` without regular expressions.

# Constants

I know you miss your `private static final` variables, my dear `java`
aficianado. For the rest of the world, constants, how do I declare something as
constant, you can't change it, don't touch it, don't even look at it!?



# Examples

# More

We skipped objects and so much more.

# Conclusion







<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
