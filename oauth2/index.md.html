<meta charset="utf-8">
                            **Elements of OAuth 2.0**
                            Stijn Heymans

# Introduction

TODO

TODO: add link to book

Note that even though I use examples like _Bank Of America_ or _mint_, I use
them for illustration purposes. These companies will be doing things
differently as they operate in the _real world_. A concept I'm not directly
bothered with.

# The User Accesses A Resource Directly

You keep neat budgets, so you decide you want to check your transactions at
[Bank of America](https://bankofamerica.com). You open up your favorite browser
and you go to said site. You click _Sign-in_ and are presented with the
classical login form:

![Classical Login](./images/classic_login.png)

You faithfully enter your username and password and get to see all your
transactions of the past month. Both Whole Foods and Amazon got too much money
from you this month, again.

![Simple OAuth](./images/simple_auth.png)

We'll your username/login combo, your _credentials_ and add to that:

!!! Tip
    OAuth 2 is not about credentials.

This example also sets the stage for identifying you (aka the human) with your
browser (your _user-agent_), we'll refer to you and your browser as one (at
this point in history, a fair assumption) and name you/your browser, the
_User_.

We will call _Bank of America_, the _Resource Owner_: they own your
transactions (the resource).


![Simple OAuth](./images/simple_auth2.png)


# The User Does not access the Resource Directly

If you do not access the resource directly, for example, you are using a
budgetting tool like [mint](mint.com) that pulls the Bank of America
transaction data for you and shows it to you nicely categorized by budget.
In this case, clearly [mint](mint.com) somehow needs access to the _Resource
Owner_ on behalf of you the _User_.

The first approach that comes to mind is, well, let [mint](mint.com) ask you
for your credentials and pass them through to Bank of America whenever you it
needs Bank of America transaction data:

![Mint First Version](./images/mint_first_version.png)

We'll usually call something like [mint](mint.com) the _Client_, so that the
general scheme looks like this:

![Mint First Version Abstracted](./images/mint_first_version_abstracted.png)

Of course, [mint](mint.com) having to ask you each time to give your
credentials is terribly annoying for you, the _User_. So [mint](mint.com) might
be tempted to think _we'll ask you once, and then we'll store it so we don't
have to ask you again_.

The flow looks exactly like above, except that now [mint](mint.com) asks you
for credentials once and then stops asking you.

What are the problems with this approach?

- _clients store your credentials_. If [mint](mint.com) gets compromised and your credentials get stolen, someone else now can access your Bank Of America account as if they were you.  You have the same problem with if Bank of America itself gets compromised of course, but this increased your risk with a factor of 2 (from 1 place that has your credentials, to 2 places that have your credentials). Imagine, you're using other clients than [mint](mint.com) to access your data. That's a third place that can get compromised.

- _anyone with your credentials has the same access you have_. Depending on what you can do as a user, someone having your credentials can do exactly what you can do. 

# OAuth 2.0

The above leads us to wanting to rethink this and find a way to give clients
appropriate access to resources you own -- giving [mint](mint.com) access to
Bank of America without that they store your credentials. If those get stolen
they'd give the thief the same access to the resource as they were you and this
until you go and change your credentials at the resource (Bank of America). In
addition, we want to make sure that clients only have the access that you
deemed appropriate (for example,  [mint](mint.com) should only be allowed to
read your transaction data but not change it).

Let's try to find solutions for a client ( [mint](mint.com) ) needing access
on your behalf without that they need to store your credentials nor ask you all
the time for your credentials. The _on behalf_ part in that sentence is why
OAuth 2.0 is considered a _delegation_ protocol rather than an authorization
protocol (so far for naming things).

## The Players

We already identified 3 players in the OAuth 2.0 delegation:

- the User (you, or a proxy for you, for example your browser)
- the Client (the application your interacting with, for example [mint](mint.com))
- the Resource Owner (the place that is the origin of your data, for example Bank Of America).

OAuth 2.0 introduces a 4th player that takes care of the actual authorization:

- the Authorization Server.

In our running example, we'll assume the authorization server is owned by Bank
Of America which makes sense as they'd be able to check your credentials which
is stored on some of their systems to be able to give you access).

## The Dance

Explain the interaction and all the concepts.  (Why do I need authorization
tokens versus access tokens. What are refresh tokens)

Start without authorization tokens and explain why that solves the problem but
has other problem (token can be intercepted) so you need authorization token.

TODO: refresh tokens

# Conclusion

Restate that OAuth states your problem. Many things left out but answers the basic why with the basic players.

We left out scopes: access tokens can control what access you have to the
resource (just read the transaction data, delete the transaction data).


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-12447521-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }

  gtag('js', new Date());

  gtag('config', 'UA-12447521-1');
</script>

<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

