<meta charset="utf-8">
                            **Elements of Ruby**
                            Stijn Heymans
                            published: 1 December 2021

# Introduction

I will introduce you to the elements of programming in
[Ruby](https://www.ruby-lang.org). I assume you can program in some other
language such as Java,
[Perl](http://www.stijnheymans.net/elements_of_perl.html), Python, Go, ...

Background sources that were helpful to me:

- [Why's (Poignant) Guide to Ruby](https://poignant.guide/) by _why the lucky
  stiff_. More art project than programming book, but a beginner's resource
  that gives an elemental overview of the language _with_ intuition of the Ruby
  language.  If you read that book, you can stop reading this article. There's
  nothing here for you.

- [Eloquent Ruby](https://www.goodreads.com/book/show/9364729-eloquent-ruby) by
  Russ Olsen. A bit more advanced than _Why's (Poignant) Guide to Ruby_. The
  book ventures into meta-programming with Ruby. To see what sets Ruby apart, I
  recommend this book.

In this article, I will follow a structure that is loosely inspired by the
structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) by Caleb
Doxsey. Not a Ruby book, but a Go, book. It's a _short_ book on Go that manages
to bring the basics across.  Something I will aspire to in this article, for
Ruby.

# Getting Started

On the command-line, check whether Ruby is installed:

~~~shell
$ ruby --version
~~~

For me, this shows `ruby 2.6.3p62 (2019-04-16 revision 67580)
[universal.x86_64-darwin20]`). If you don't have Ruby installed, get it at [the
ruby-lang website](https://www.ruby-lang.org/en/downloads/).

If you have Ruby installed, you also have an interactive interpreter called
[irb](https://github.com/ruby/irb). On the command-line, type `irb`.

~~~
irb> puts 'Hello World!'
Hello World!
=> nil
~~~

Leave the interactive interpreter `irb` by typing `exit`. Now let's a `Hello World!` again, but
without `irb`. Open a file (make it end on `rb`, for example
`ruby_playground.rb`) and write the following line in it:

~~~ruby
puts 'Hello World!'
~~~

Close the file and at the command-line, have Ruby execute it:

~~~
$ ruby ruby_playground.rb
Hello World!
~~~

Do you want to know more about `puts`? Get in the habit of using the [official
docs](https://docs.ruby-lang.org/en/).  Pick the right version of the docs
corresponding to what you saw in your initial `ruby --version`. I picked
`2.6.0` as my Ruby version is `2.6.3` and found this
[explanation](https://docs.ruby-lang.org/en/2.6.0/ARGF.html#method-i-puts).

# The Basic Classes

## Numbers

Unsurprisingly, integers are represented as we expect: `3`, `5`, `-100`, ...
Surprisingly, everything in Ruby is an object so you can ask the class of an
integer: `5.class`. This returns
[Integer](https://docs.ruby-lang.org/en/2.6.0/Integer.html). 

Since integers are objects there's more fun stuff one can ask them: 

~~~
irb> 123.digits
=> [3, 2, 1]
~~~

Fans of coding interviews will appreciate this. That's the only place you will
ever need that.

Simple math is ready for you and has been since you were 7:

~~~
irb> 1 + 2
=> 3
irb> 2 * 3
=> 6
irb> 8 / 4
=> 2
~~~

There's also the number type that keeps it real and inexact, le
[Float](https://docs.ruby-lang.org/en/2.6.0/Float.html). In its literal
representation, it's _things_ that contain a decimal point:`1.0`, `9.9999`, ...

~~~
irb> 1.0.class
=> Float
~~~

First encounters are frequently unpleasant:

~~~
irb> 7 / 2
=> 3
~~~

Dividing 2 integers results in integer division. Force one to be a `Float`
using `to_f`:

~~~
irb> 7.to_f / 2
=> 3.5
~~~

## Strings

String are characters surrounded by single quotes or double quotes: `'Hello'`
or `"Hello"`. The double-quoted variety is special. More later. Be patient.

Use `+` to concatenate 2 strings without changing the original strings. Use
`<<` to concanate and destroy the string you're appending to:

~~~
irb> a = "hello"
=> "hello"
irb> b = "world"
=> "world"
irb> a + b
=> "helloworld"
irb> a
=> "hello"
irb> b
=> "world"
irb> a << b
=> "helloworld"
irb> a
=> "helloworld"
irb> b
=> "world"
~~~

Pull characters out of a String:

~~~
irb> a = "hello"
=> "hello"
irb> a[0]
=> "h"
irb> a[-1]
=> "o"
~~~

You can get substrings by using inclusive (`..`) or exclusive (`...`) ranges:

~~~
irb> a = "hello"
=> "hello"
irb> a[0..2]
=> "hel"
irb> a[0...2]
=> "he"
~~~

## Symbols

Symbols consist of letters, digits, or underscores, and are preceded by a `:` .
For example, `:a`, `:a_2`, `:an_orange`. Why not just use Strings? [Great
question](https://stackoverflow.com/questions/255078/whats-the-difference-between-a-string-and-a-symbol-in-ruby).

Let's explore how strings are different from symbols by asking for their
`object_id`:

~~~
irb> "bar".object_id
=> 70236502854760
irb> "bar".object_id
=> 70236502887440
irb> :foo.object_id
=> 1516508
irb> :foo.object_id
=> 1516508
~~~

From that `irb` session, you can (if you truly want) learn that

- every object has a method `object_id` that returns _some_ id.
- strings that appear the same do not necessarily have the same `object_id`, which _probably_ has memory consequences
- symbols that appear the same have the same `object_id`, which _probably_ has memory consequences

## Booleans

`true` and `false`. This section seems awfully incomplete doesn't it? It's not.

# Variables

Like symbols they consist of letters, digits, or underscores. Unlike symbols,
they do not start with colons. You initialize them:

~~~
irb> x = 'hello'
=> "hello"
irb> x = 5
=> 5
irb> x = true
=> true
~~~

I assigned and re-assigned that `x` to my heart's content with different values
_and_ different types.

You feel resistance. "But this is insane," you say. You do not like it and you
want the world to know it. You take the matter to twitter, but twitter is just
an empty army of machines.  No-one listens, not truly, not anymore. It's 2021
kid, the humans lost.

And as far as single and double quotes go: 

~~~
irb> x = 2
=> 2
irb> "we were #{x}"
=> "we were 2"
irb> 'we were #{x}'
=> "we were \#{x}"
~~~

[String interpolation](https://en.wikipedia.org/wiki/String_interpolation) yes.

And sometimes variables are not so variable:

~~~
irb> X = 5
=> 5
irb> X = 6
(irb):5: warning: already initialized constant X
~~~

Capitalize your variable and it becomes _constant_. 

A word on camels and snakes when naming variables or really anything. Use snake
case almost everywhere: `lowercase_words_separated_by_underscores`. Except
`ClassNames`, go for camel case there. Later more on classes.

# Control Structures

## Conditions and `if`

Here's the basic form of an `if`:

~~~ruby
if condition
  do_something
end
~~~

So no parentheses as in `(condition)`, no colon as in `condition:`, no curly brackets
as in `{ do_something }`). And `end` to end it.

The usual `else if` and `else`:

~~~ruby
if condition
  do_something
elsif other_condition
  do_something_else
else
  final_thing_you_can_do
end
~~~

Conditions in `if` statements are expressions that evaluate to true or false.
What expressions evaluates to true?

- all numbers (including `0`) are true
- all strings (including `''` -- the empty string) are true
- `nil` (yep, that's a null right there) is false
- the boolean literal `true` is true
- the boolean literal `false` is false
- the boolean expression `a && b` is true if `a` and `b` are true
- the boolean expression `a || b` is true if `a` or `b` are true
- the boolean expression `!a` is true if a is not true

Your conditions will often compare things: if variable `a` is equal to `"dog"`,
then do this. While Ruby has `==`, `===`, `equal?`, and `eql?`, you
will mostly use:

- `==` for checking whether values are equal as far as the class designer of the objects you're comparing is concerned. 
- `equal?` for checking object equality.

In fact, `equal?` and `==` as defined in the
[`Object`](https://ruby-doc.org/core-3.0.2/Object.html#method-i-eql-3F) are
equal. Pun intended.

The intent is that class designers override `==` to something that
makes sense for the class, but that `equal?` always stands for object
equality. Take the `String` class:

~~~
irb> "a" == "a"
=> true
irb> "a".equal?("a")
=> false
~~~

So `"a"` is equal to `"a"` as values, but, as we saw before, they're not the same
objects. However, for symbols:

~~~
irb> :a == :a
=> true
irb> :a.equal?(:a)
=> true
~~~

Back to our `if` for a bit. Instead of:

~~~ruby
if !condition
  do_something
end
~~~

write:

~~~ruby
unless condition
  do_something
end
~~~

Furthermore, if `do_something` is just one line, Ruby often prefers the one-liner:

~~~ruby
do_something if condition
~~~

or

~~~ruby
do_something unless condition
~~~

Especially when returning early from functions, this makes code readable:

~~~ruby
return if invalid_parameters
~~~

## Looping

Take a look at a relatively standard loop-pattern in programming. For example, this `go` loop:

~~~go
n := 5
for i := 0; i < n; i++ {
  fmt.Println(i)
}
~~~

This prints:

~~~
0
1
2
3
4
~~~

There's a variety of ways to write this in Ruby, but the above classic `for`
construct is not one of them.  Closest in spirit is to
use a `while`:

~~~ruby
n = 5
i = 0
while i < n
  puts i
  i += 1
end
~~~

This is more verbose than the corresponding `for` loop in `go`.
More idiomatic Ruby uses [`times`](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times):

~~~ruby
n.times { |i| puts i }
~~~

More elegant than the clunky `while`.  Deconstruct this expression:

- `n`. An `Integer`, and thus an object that has methods.
- `times`. A [method](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times) that is called on the object `n` and _iterates_ the following block `{ |i| puts i}` from `0` to `n - 1`, passing in those values to `i` with each iteration. More on blocks later, but for those familiar, the block is essentially an anonymous function or lambda with parameter `i` (or arrow function for the Javascript knowledgeables). 
- `{ |i| puts i }`. We spoiled it. This is a `block` that prints `i` with `i` ranging over values `0` to `n - 1`. This _ranging over values_ is accomplished by `times`. We'll see later how we can write functions such as `times` ourselves in the section on Blocks. For now, you can see `times` as an higher-order function that takes another function as an argument.

Most of the time your looping will be in the context of some collection so I'll
talk more about looping in that section.

# Collections

## Arrays

An array is an [ordered integer-indexed collection](https://docs.ruby-lang.org/en/2.6.0/Array.html) of objects. Let's initialize one:

~~~
irb> a = ["x", 1, :y]
=> ["x", 1, :y]
~~~

Arrays are not restricted to contain only 1 type of objects. You can shove
in there what you like: 

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
~~~

The usual suspects with a special mention for `-1` (the last of the elements):

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb> a.length
=> 3
irb> a[1]
=> [1, 2]
irb> a[-1]
=> :y
~~~

You can add elements to the back of an array using `<<` or `push`. Both are destructive operations:

~~~
irb> a << :b
=> ["x", [1, 2], :y, :b]
irb> a.push(:c)
=> ["x", [1, 2], :y, :b, :c]
irb> a
=> ["x", [1, 2], :y, :b, :c]
~~~

You can remove that last element again using `pop`:

~~~
irb> l = a.pop
=> :c
irb> a
=> ["x", [1, 2], :y, :b]
~~~

What about adding and removing to the _front_ of an array? Use `unshift` and `shift`. As far as unsavory mnemonics go, remove the `f` to remember which does what.

~~~
irb> a
=> ["x", [1, 2], :y, :b]
irb> f = a.shift
=> "x"
irb> a
=> [[1, 2], :y, :b]
irb> a.unshift("x_new")
=> ["x_new", [1, 2], :y, :b]
~~~

`pop/push` must be more efficient than `shift/unshift`? Seems it [hardly
matters](https://stackoverflow.com/questions/8353026/what-is-the-run-time-of-shift-unshift-in-a-ruby-array).

What if you have a second array `b = [:b1, :b2]` that you want to append (i.e., add each element) to `a`? Just using `push` will not do what you want:

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb> b = [:b1, :b2]
=> [:b1, :b2]
irb> a.push(b)
=> ["x", [1, 2], :y, [:b1, :b2]]
~~~

However, using the _splat_ operator `*` will:

~~~
irb> b = [:b1, :b2]
=> [:b1, :b2]
irb> a.push(*b)
=> ["x", [1, 2], :y, :b1, :b2]
~~~

`*b` for an array `b` in the context of a function call (`push` here) will send
each element of the array as an individual argument to the function. Thus,
`a.push(*b)` is the same as `a.push(:b1, :b2)`.

I initialized arrays using their literal form (such as `a = [1, 2]`).  I can
also initialize them using the `new` method from the
[Array](https://docs.ruby-lang.org/en/2.6.0/Array.html) class:

~~~
irb> a = Array.new
=> []
irb> a << 1
=> [1]
~~~

## Hashes

[Hashes](https://docs.ruby-lang.org/en/2.6.0/Hash.html) are structures that store
key-value pairs with unique keys (also called dictionaries, associative arrays,
`HashMap`, maps in other languages). You can use any object type as a key.

Let's define a hash with some personal information and get a
value for an existing/non-existing key, change a value for an existing
key, add a value for a non-existing key, and remove a key/value pair:

~~~
irb> a = { "first" => "John", "last" => "Doe" }
=> {"first"=>"John", "last"=>"Doe"}
irb> a["first"]
=> "John"
irb> a["nothere"]
=> nil
irb> a["first"] = "Jane"
=> "Jane"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
irb> a["first"]
=> "Jane"
irb> a["nothere"] = "now it is here"
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe", "nothere"=>"now it is here"}
irb> a.delete("nothere")
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
~~~

What type of objects can be values? Any object.
What type of objects can be keys, surely only strings right? Any object.

In the above rundown, all keys were strings. When keys are symbols, there's
some syntactic sugar that tastes almost like the real thing:

~~~
irb> a = { :first => "John", :last => "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a[:first]
=> "John"
~~~

Nothing interesting happened. You used symbols `:first` and `:last` as keys.
However, if you want symbols as keys, you can party as wild as JSON does on
Friday night, evoking nothing but bleak memories of what used to be a life with
promise:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
~~~

I confidently said you can use any object as a hash key. This relies on properly
overriding `hash` and `eql?` (the latter being what
[Hash](https://docs.ruby-lang.org/en/2.6.0/Hash.html) uses for testing equality
of keys. [Two objects will then refer to the same key when their `hash` value
is identical and the 2 objects `eql?` each
other](https://docs.ruby-lang.org/en/2.6.0/Hash.html#class-Hash-label-Hash+Keys).
Is this still elemental? Probably not. Moving on.

## Looping through Arrays and Hashes

You will spend half of your life looping through arrays and hashes. Given an array:

~~~
a = [100, 200, 300]
~~~

Print each element:

~~~
a.each { |el| puts el }
~~~

No `for` in sight. Use `each` when you can. `each` iterates through the
elements of the array and binds each of those elements to _el_ in the block `{
|el| puts el }`, and then executes the `puts el`. If you need more than a
one-liner, do use `do...end`:

~~~ruby
a.each do |el|
  puts el
  puts el
end
~~~

Sometimes you want the index as well as the element (mostly in interviews, in
real life not so much). So similar to the trickery we saw before you could do:

~~~ruby
a.length.times { |i| puts a[i] }
~~~

However, the thought police favors `each_with_index`:

~~~
irb> a.each_with_index { |el, i| puts "#{i}: #{el}" }
0: 100
1: 200
2: 300
~~~

Yeah, get those [Anki flashcards](https://apps.ankiweb.net/) out to memorize
the order of that `|el, i|`. You did not ask for it, but here's a tip: in Ruby, it often works to
ask "how would I say this out loud?". 

!!!
   In the array `a`, for _each_ `el` at index `i`, do something. 

If your intuition is _for each index `i` which has element `el`_, change your
intuition.

You can loop over a hash with `each`:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> John
last -> Doe
~~~

Sometimes you only want to loop through the keys or values of a hash. You can
use `keys` and `values`:

~~~
irb> a.keys
=> [:first, :last]
irb> a.values
=> ["John", "Doe"]
~~~

In contrast to hashes in other languages (e.g. `HashMap` in Java), you _can_
assume an order on key-value pairs. They will be in the order they were
inserted:

~~~
irb> a = {}
=> {}
irb> a["first"] = 1
=> 1
irb> a["second"] = 2
=> 2
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> 1
second -> 2
~~~

Sometimes you can benefit from going one abstraction higher than pure looping,
and use a [`map`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map):

~~~
irb> a = [1, 2, 3]
=> [1, 2, 3]
irb> b = a.map { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [1, 2, 3]
~~~

If you do not want a new array, you can use the [destructive variant
`map!`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map-21):

~~~
irb> a.map! { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [2, 4, 6]
~~~

I know you saw the exclamation mark. That was not an indication of surprise (_"a `map` here?!"_). The convention in Ruby is to append `!` to function names if those
functions are supposed to be destructive. The exclamation mark is a regular
part of the function name.

We can also map hashes. For example, collect all keys of a map, but uppercased:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.map { |key, value| key.upcase }
=> [:FIRST, :LAST]
~~~

What if you want to map a Hash to a Hash, but just keeping the keys but
uppercasing the values?

~~~
irb> a.map { |key, value| [key, value.upcase] }.to_h
=> {:first=>"JOHN", :last=>"DOE"}
~~~

The `map` returns an array of `[key, value.upcase]` arrays. So I use `to_h` to
convert that very specific array to a hash.  Generally:

~~~
irb> [[1, 2], [3, 4]].to_h
=> {1=>2, 3=>4}
~~~

We're verging to the non-elemental.

# Functions

Your first unit of abstraction are functions (or _methods_, when appearing in classes, same potato). Functions take the following shape:

~~~ruby
def function_name(arg1, arg2,...)
  # do stuff
end
~~~

Functions start with `def` and end with `end`. A function that doubles an array `a`:

~~~ruby
def double_all(a)
  a.map { |x| x * 2 }
end
~~~

"Oh no," you may say. "They forgot to type the arguments, what a nightmare to
read code like that,". Yes, but embrace it. Essentially, your `a` can be
anything as long as it understands `map`. Yes, yes, interfaces and all. 

Calling functions is as you would expect:

~~~
irb> a = [1, 2, 3]
irb> puts double_all(a)
2
4
6
~~~


You have options if you do not want to embrace it. Check out
[sorbet](https://sorbet.org/) which allows you to annotate your functions with
type information. For example, the above would be intended for:

~~~ruby
sig { params(a: T::Array[Integer].returns(T::Array[Integer]) }
def double_all(a)
  a.map { |x| x * 2 }
end
~~~

You can have defaults for your arguments:

~~~ruby
def double_all(a = [1, 2])
  a.map { |x| x * 2 }
end
~~~

You can then just do:

~~~
irb> puts double_all
2
4
~~~

You can have of courses have a hash as an argument:

~~~ruby
def hash_keys(h)
  puts "a: #{h[:a]}"
  puts "b: #{h[:b]}"
end
~~~

And then:

~~~
irb> puts hash_keys({ a: 1, b: 2 })
a: 1
b: 2
~~~

Here's some fun. If a hash is the last argument of the function call, you can just leave off the curly brackets:

~~~
irb> puts hash_keys(a: 1, b: 2)
a: 1
b: 2
~~~

That looks a whole lots like keyword arguments at that point. And yes, it's
easy to see that you could now just change the calling order without effects:

~~~
irb> puts hash_keys(b: 2, a: 1)
a: 1
b: 2
~~~

# Classes and Methods

A minimal class is defined with the `class` keyword, a name, and ends with `end`:

~~~ruby
class A

end
~~~

Despite this not doing much more then introducing `A` into your world. Let's see how to create a new `A` object `a`, how to ask it's `object_id`, how to get its string representation with `to_s` and finally how to ask an objects it's class:

~~~
irb> a = A.new
=> #<A:0x00007f913a9bb5e0>
irb> a.to_s
=> "#<A:0x00007f913a9bb5e0>"
irb> a.object_id
=> 70130865134320
irb> a.class
=> A
~~~

Not bad for a minute of work. You may be wondering where does all this functionality come from. Let's poke at the class hierarchy:

~~~
irb> a.class.ancestors
=> [A, Object, Kernel, BasicObject]
~~~

So `a` is an `A` which is an `Object` which is a `Kernel`, which is a
`BasicObject`. Forget about the latter 2. Do it. And note that of course
`Object` already has all that functionality, so we're merely tapping into
_inherited_ methods from `Object`:

~~~
irb> o = Object.new
=> #<Object:0x00007f913a82f898>
irb> o.to_s
=> "#<Object:0x00007f913a82f898>"
irb> o.object_id
=> 70130864323660
irb> o.class
=> Object
irb> o.class.ancestors
=> [Object, Kernel, BasicObject]
~~~

What about equality of such objects?

~~~
irb(main):013:0> a = A.new
=> #<A:0x00007f913d853380>
irb(main):014:0> b = A.new
=> #<A:0x00007f913d85a478>
irb(main):015:0> a == b
=> false
~~~

You may be used to constructors in other languages that get called by when
creating new objects using `new`. With an empty class we just use the
`initialize` of `Object`, but if you want to use your own (and you almost
always want to), here's how that would go:

~~~ruby
class A

  def initialize
    puts "you called new didn't you?"
  end

end
~~~

And then creating a new `A` would show:

~~~
irb> a = A.new
you called new didn't you?
=> #<A:0x00007fc4eb1b8bd8>
~~~

The class `A` is mostly useless. Usually classes carry some _state_ (cars have
doors and color, some cars have 4 doors, some 5, some cars are blue, some cars
are yellow). We capture that state using instance variables.

In Ruby, instance variables start with an `@`. So for example, let's give `A` some state:

~~~ruby
class A

  def initialize
    @a = 10
  end

  def print_your_state
    puts "my state is #{@a}"
  end

end
~~~

We did two things that are new:

- we're setting the value of `@a` in the `initialize`. Given what you know at this point, you'd expect that when you create a new `A` object that `@a = 10` line gets executed
- we've introduce an _instance_method_ called `print_your_state`. If you have an `A` object called `x` you can do `x.print_your_state`. This will execute the `puts` line for your object `x`.

~~~
irb> x = A.new
=> #<A:0x00007fc4ea1190c0 @a=10>
irb> x.print_your_state
my state is 10
~~~

Of course, every object would have `@a` equal to 10, whereas you'd like to
create objects with different states. You can accomplish this unexpectedly by
giving `initialize` arguments:

~~~
irb> x = A.new(10)
=> #<A:0x00007fc4eb1c1f80 @a=10>
irb> y = A.new(11)
=> #<A:0x00007fc4e9832c40 @a=11>
irb> x.print_your_state
my state is 10
irb(main):014:0> y.print_your_state
my state is 11
~~~

You can of course also give instance methods arguments:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def print_your_state_with_a_factor(x)
    result = @a * x
    puts "my state is #{result}"
  end
~~~

And then:

~~~
irb> x = A.new(10)
=> #<A:0x00007fc4eb145778 @a=10>
irb> x.print_your_state_with_a_factor(3)
my state is 30
~~~

This is interesting in that `result` is a _local_ variable to the instance
method `print_your_state_with_a_factor` and thus there's no `@` in sight when
`put`ing it.

Note that instance variables are _encapsulated_: you cannot get to its value from outside the class:

~~~
irb> x = A.new(3)
=> #<A:0x00007fc8cc180280 @a=3>
irb> x.a
Traceback (most recent call last):
        4: from /usr/bin/irb:23:in `<main>'
        3: from /usr/bin/irb:23:in `load'
        2: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        1: from (irb):4
NoMethodError (undefined method `a' for #<A:0x00007fc8cc180280 @a=3>)
~~~

That makes some sort of sense thinking of, for example, private instance variables in Java. You'd usually define a getter of some sorts:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def a
    @a
  end
end
~~~

And then:

~~~
irb> x = A.new(3)
=> #<A:0x00007f913a943c70 @a=3>
irb> x.a
=> 3
~~~

You could still not write to `@a` as that requires some sort of setter:

~~~
irb> x.a = 5
Traceback (most recent call last):
        4: from /usr/bin/irb:23:in `<main>'
        3: from /usr/bin/irb:23:in `load'
        2: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        1: from (irb):20
NoMethodError (undefined method `a=' for #<A:0x00007f913a943c70 @a=3>)
Did you mean?  a
~~~

We can write this ourselves:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def a
    @a
  end

  def a=(a)
    @a = a
  end
end
~~~

and then:

~~~
irb> x = A.new(3)
=> #<A:0x00007fb09b838558 @a=3>
irb> x.a
=> 3
irb> x.a = 5
=> 5
irb> x.a
=> 5
~~~

I'll pause, so you can take this in.

~~~ruby
def a=(a)
  @a = a
end
~~~

That latter thing is an [assignment method](https://docs.ruby-lang.org/en/2.6.0/doc/syntax/assignment_rdoc.html#label-Assignment+Methods).
At this point the whole thing has become terribly obnoxious. Luckily, we have shorthand. We can accomplish what we had (a getter and a setter), by using `attr_accessor` as follows:

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end
end
~~~

Yes, you write `:a` there. 

~~~
irb> x = A.new(3)
=> #<A:0x00007fc5ab109988 @a=3>
irb> x.a
=> 3
irb> x.a = 6
=> 6
~~~

If you only want the getter, you can use `attr_reader`. If you only want a
setter (who are you?), you can use `attr_writer`.

As for some fun. What do you think will `x == y` be?

~~~
irb> x = A.new(3)
=> #<A:0x00007fa3d6194778 @a=3>
irb> y = A.new(3)
=> #<A:0x00007fa3d58ed458 @a=3>
irb> x == y
~~~

That's right. False. `x` and `y` are different objects and `==` is using
`Object` equality in this case. Sometimes it makes sense, to have `x` and `y`
be equal as they represent the same data namely an `A` with data `3`. If you
think, "yeah right", think of strings: `"I am right" == "I am right"` are the
same strings and we expect this to be `true`.

You can override `==` to accomplish that.

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end

  def ==(other)
    self.a == other.a
  end
end
~~~

And then:

~~~
irb> x = A.new(3)
=> #<A:0x00007fb47c1805a0 @a=3>
irb> y = A.new(3)
=> #<A:0x00007fb47c189268 @a=3>
irb> x == y
=> true
~~~

Couple of things worth pointing to:

- `==` can be just an instance method defined as any other method.  The reason is that `x == y`, is really just `x.==(y)` as if `==` is any other method name.
- I used `self` which is very similar to Java's `this` at least in _this_ [context](https://airbrake.io/blog/ruby/self-ruby-overview). Here it's the an instance of this object itself. So when we're doing `x == y`, and we thus execute `==` for the object `x`, then `self` would be `x`. Caveat emptor: `self` may mean other things. We will see in a bit how to use `self` to define _class methods_. 
- I did not actually have to use `self` here. There was no ambiguity if I'd have done `a == other.a`. The first `a` would have referred to the method `a` defined in `A` (by way of the `attr_accessor` and would have allowed me to check equality of the instance variable `@a` with `other.a` (aka the `@a` of the `other` object).

If you know `Java`, you must have met `static`. Used to indicate both variables
and methods in Java classes that belong to the type rather than the instance.
Aka, you can ask the class for the variables/methods. No need for an object. 

In Ruby _class variables_ are indicated with `@@` (recall that instance
variables are indicated with `@`). _Class methods_ are indicated by preceding
the name with `self`. The body is not yet cold and here we are: `self` in this
context, refers to the class (rather than the object). Let's see this in
practice:

~~~ruby
class A
  @@counter = 0

  def initialize
    @@counter += 1
  end

  def self.counter
    @@counter
  end

end
~~~

And then:

~~~
irb> x = A.new
=> #<A:0x00007fc82595ce60>
irb> A.counter
=> 1
irb> y = A.new
=> #<A:0x00007fc8259642a0>
irb> A.counter
=> 2
~~~

Note that we asked `A` for the `counter` (not `x`, nor `y`). In fact, doing
`x.counter` would lead to an `undefined method` error.

I avoided it for a while, but let's talk about inheritance. In the below I make `B` a subclass of `A` by indicating `B < A`.

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end

  def double
    2 * @a
  end
end

class B < A
  def triple
    3 * @a
  end
end
~~~

And some poking at this:

~~~
irb(main):011:0> x = A.new(3)
=> #<A:0x00007fa19e02dd10 @a=3>
irb(main):012:0> x.double
=> 6
irb(main):013:0> y = B.new
Traceback (most recent call last):
        6: from /usr/bin/irb:23:in `<main>'
        5: from /usr/bin/irb:23:in `load'
        4: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        3: from (irb):13
        2: from (irb):13:in `new'
        1: from /Users/sheymans/Workspaces/ruby_playground/src/ruby_playground.rb:7:in `initialize'
ArgumentError (wrong number of arguments (given 0, expected 1))
irb(main):014:0> y = B.new(5)
=> #<B:0x00007fa19f2184a8 @a=5>
irb(main):015:0> y.double
=> 10
irb(main):016:0> y.triple
=> 15
~~~

This works you expect it to work. Some quick notes:

- I did not give an `initialize` to `B` so we're forced to use the one of `A` which requires 1 argument `a` (which is what the _wrong number of arguments_ tells us)
- I could access the instance variable `@a` in `B`, given that was initialized in `A`. This could be surprising as in _where in the name does `@a` here comes from?_. I hope you got a decent IDE going for you.

# Modules

The general syntax of a module is easy. Use keyword `module`, give it a name and end with `end`:

~~~ruby
module HomeMade
  class A
    attr_accessor :a

    def initialize(a)
      @a = a
    end

    def double
      2 * @a
    end
  end

end
~~~

And then prepend `HomeMade::` to your class name `A` if you want an instance of this particular `A`:

~~~
irb> a = HomeMade::A.new(3)
=> #<HomeMade::A:0x00007fdf07147448 @a=3>
irb> a.double
=> 6
~~~

## As Namespaces

But why? One simple reason is that your neighbor also would like a class with
name `A`. That's just how he is. With modules, you can nicely isolate names:

~~~ruby
module HomeMade
  class A
    attr_accessor :a

    def initialize(a)
      @a = a
    end

    def double
      2 * @a
    end
  end
end

module NeighborMade
  class A
    # Same name A
  end
end
~~~

And now you can nicely differentiate which `A` you mean:

~~~
irb> a = HomeMade::A.new(3)
=> #<HomeMade::A:0x00007f95eb03f0b0 @a=3>
irb> b = NeighborMade::A.new
=> #<NeighborMade::A:0x00007f95ef0ef998>
~~~

In other words, modules can help you logically organize your classes/functions
within your application.

## As Mixins

Say you have 2 modules, 1 for logging and 1 for doing more long-term analytics (like sending Kafka events):

~~~ruby
module Logger
  def log_it(what)
    puts what
  end
end

module Analytics
  def send_event(event)
    puts event
  end
end
~~~

And you have a class `A` that would like to re-use the methods provided by both the `Logger` and `Analytics` modules:

~~~ruby
class A

  def do_something
    log_it("we're logging this")
    send_event('for long term analytics we send this')
  end
end
~~~

Trying this as is, will give you a `NoMethodError` for `log_it` and `send_event` if you try to do `a.do_something` for an object `a` of type `A`. `A` does not know about these things. You could be clever and say, well, let `A` inherit from `Logger`. Yes. And you'd want `A` to also inherit from `Analytics`. However, Ruby does not allow multiple inheritance. You can only inherit from 1 class (ignoring for a minute that `Logger` and `Analytics` are not actually classes, they are modules).

We can solve this by _mixing in_ the 2 modules in the class `A` by using `include`:

~~~ruby
class A
  include Logger
  include Analytics

  def do_something
    log_it("we're logging this")
    send_event('for long term analytics we send this')
  end
end
~~~

`include` makes all methods of the modules available as _instance_ methods in
your class. In the Java world, and maybe other worlds as well, you are reminded
immediately of the dreaded Utility class. Banish that memory.

# Testing

Say you have a class `A` that doubles, defined in a file `ruby_playground.rb`:

~~~ruby
class A
  def initialize(a)
    @a = a
  end

  def double
    @a * 2
  end
end
~~~

Let's unit test `double` by creating a new file `test_ruby_playground.rb` for it:

~~~ruby
require 'test/unit'
require './ruby_playground'

class RubyPlayGroundTest < Test::Unit::TestCase
  def test_double
    a = A.new(3)
    assert_equal 6, a.double
  end

end
~~~

This should look fairly familiar by now. Some new things:

- we `require` the `test/unit` Ruby gem which defines the class `Test::Unit::TestCase` for us.
- we `require` the file that has our own `A` with its `double`
- we create a new class `RubyPlayGroundTest` that inherits from that `Test::Unit::TestCase`
- we write a method that starts with `test_` and we use `assert_equal` to test whether `6` is indeed the result of `a.double`.

Running that test file should result in success with statistics:

~~~
$ ruby test_ruby_playground.rb
Loaded suite test_ruby_playground
Started
.
Finished in 0.000298 seconds.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1 tests, 1 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications
100% passed
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3355.70 tests/s, 3355.70 assertions/s
~~~

Try making the test fail and run the test again. Do it.

# Blocks


A quick reminder that we already saw blocks in action:

~~~
irb> a = [1, 2, 3]
=> [1, 2, 3]
irb> a.map { |el| el * 2 }
=> [2, 4, 6]
~~~

The piece `{ |el| el * 2 } is a _block_. You can distinguish the parameter part
`|el|` as well as the _body_ of that block `el * 2`. For multi-line blocks,
you'd use the `do...end` form, same potato though:

~~~ruby
a.map do |el|
 double = el * 2
 double + 1
end
~~~

Essentially you're giving one function `map` another function (the block) as an
argument. It's what they call higher-order functions in school children.

How do you define your own higher order function? Let's define a function that starts by printing "here we are now", and ends by printing "entertain us" to whatever function call we'd like. For example, say we want to print those 2 lines around a function call of `lost`:

~~~ruby
def lost
  puts 'a lost generation'
end
~~~

We could of course just do:

~~~ruby
puts 'here we are now'
lost
puts 'entertain us'
~~~

But if I'd want to do the same to another function than `lost` I'd have to repeat that. Let's define a higher-function that can prints those things for any other function:

~~~
def smells_like
  puts 'here we are now'
  yield
  puts 'entertain us'
end
~~~

You saw it: `yield`. That keyword tells the function `smells_like` _and now
execute the block that was given to your call my friend_. So if we do
`smells_like { lost }`, you see:

```
here we are now
a lost generation
entertain us
```

You could also just do `smells_like { puts 'a broken generation' }` and see:

```
here we are now
a broken generation
entertain us
```

What about blocks with parameters? For example, what if I want to be able to do
`smells_like('broken') { |x| puts "a #{x} generation" }`? `yield` can take
arguments, and yields arguments get shuttled into the block's arguments:

~~~ruby
def smells_like(something)
  puts 'here we are now'
  yield(something)
  puts 'entertain us'
end
~~~

And then:

~~~
irb> smells_like('lost') { |x| puts "a #{x} generation" }
here we are now
a lost generation
entertain us
irb> smells_like('broken') { |x| puts "a #{x} generation" }
here we are now
a broken generation
entertain us
~~~

Good times.

# Conclusion

We reached the end.


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

