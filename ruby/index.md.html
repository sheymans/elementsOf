<meta charset="utf-8">
                            **Elements of Ruby**
                            Stijn Heymans


# Introduction

I will attempt to introduce you to the elements of programming in
[Ruby](https://www.ruby-lang.org) from a beginner's mindset. I will assume you
can program in some other language (Java,
[Perl](http://www.stijnheymans.net/elements_of_perl.html), Python, whatever)
and so I'll not explain recursion, object-oriented programming, or other
concepts common to most programming languages.

I will mostly use 2 sources that were helpful to me and are worth digging into yourself:

- [Why's (Poignant) Guide to Ruby](https://poignant.guide/) by _why the lucky stiff_. That book is more art project than programming book, but it's also the one beginner's resource I found that gives an elemental overview of the language _with_ intuition of why things are the way they are in Ruby. If you already read that book, you can stop reading this article. You will not learn anything more than you already know.

- [Eloquent Ruby](https://www.goodreads.com/book/show/9364729-eloquent-ruby) by Russ Olsen. This takes things a step further and highlights the _Ruby_ way of doing common tasks, but also goes into meta-programming with Ruby that is easy to understand and gives you an inkling why Ruby might be different than some of the other languages out there.

Finally, and the source that stands a bit out, I will follow a structure that is
loosely inspired by the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) by Caleb
Doxsey. It's a great little book on Go, but most of all it's a great little
_short_ book on Go that manages to bring the basics across without decorum.
Something I aspire to in this article. Let's try.

# Getting Started

I assume you have some familiarity with basic command-line usage. Check whether
ruby is installed:

~~~shell
$ ruby --version
~~~

For me, it returns `ruby 2.6.3p62 (2019-04-16 revision 67580)
[universal.x86_64-darwin20]`). If you don't have it installed, you can get it
at [the ruby-lang website](https://www.ruby-lang.org/en/downloads/).

If you have ruby, you will have an interactive interpreter called
[irb](https://github.com/ruby/irb). On the command-line, type `irb`.

~~~
irb> puts 'Hello World!'
Hello World!
=> nil
~~~

Leave the interactive interpreter `irb` by typing `exit`. Now the same but
without `irb`. Open a file (make it end on `rb`, for example
`ruby_playground.rb`) and put the following line in it:

~~~ruby
puts 'Hello World!'
~~~

Close the file and at the command-line, have ruby execute it:

~~~
$ ruby ruby_playground.rb
Hello World!
~~~

Want to know more about `puts`? Get in the habit of looking that sort of info
up in the [official docs](https://docs.ruby-lang.org/en/) -
pick the right version of the docs corresponding to what you saw in your
initial `ruby --version`. I picked `2.6.0` as my ruby version is `2.6.3`.

This got us started.

# The Basic Classes

## Numbers

Unsuprisingly, integers are represented as we expect: `3`, `5, `-100`, ...
Suprisingly, everything in ruby is an object so you can ask the class of an
integer by doing `5.class`, which will return
[Integer](https://docs.ruby-lang.org/en/2.6.0/Integer.html). 

Since they're full-fledged objects there's more fun stuff one can do: 

~~~
irb> 123.digits
=> [3, 2, 1]
~~~

Yep, you can get an array of all digits that make up the integer. Fans of
coding interviews will like that, cause that's literally the only place you'll
ever need that.

You can do the usual math:

~~~
irb> 1 + 2
=> 3
irb> 2 * 3
=> 6
irb> 8 / 4
=> 2
~~~

Besides integers, you have our favorite inexact real numbers, represented by
[Float](https://docs.ruby-lang.org/en/2.6.0/Float.html) and in its literal form
things containing a decimal point:`1.0`, `9.9999`, ...

~~~
irb> 1.0.class
=> Float
~~~

First encounters are often unpleasant:

~~~
irb> 7 / 2
=> 3
~~~

Dividing 2 integers results in integer division. Force one to be a `Float`
using `to_f`:

~~~
irb> 7.to_f / 2
=> 3.5
~~~

## Strings

String are any characters surrounded by single quotes or double quotes:
`'Hello'` or `"Hello"`. The double-quoted variety are a bit special. I'll show
after talking about variables.

## Symbols

Symbols consist of letters, digits, or underscores, and are preceded by a `:`.
For example, `:a`, `:a_2`, `:an_orange`. Well, why not just use Strings? [Great
question](https://stackoverflow.com/questions/255078/whats-the-difference-between-a-string-and-a-symbol-in-ruby).

Remember that I said everything is an object? So let's look a bit at how strings are different from objects:

~~~
irb> "bar".object_id
=> 70236502854760
irb> "bar".object_id
=> 70236502887440
irb> :foo.object_id
=> 1516508
irb> :foo.object_id
=> 1516508
~~~

You can learn several things from this:

- every object apparently has a method `object_id` that gives some sort of id.
- strings that look the same do not necessarily have the same `object_id`, which _probably_ has memory consequences
- symbols that look the same have the same `object_id`, which _probably_ has memory consequences

## Booleans

`true` and `false`. There.


# Variables

Like symbols they consist of letters, digits, or underscores. Unlike symbols,
they do not start with colons. You initialize them:

~~~
irb> x = 'hello'
=> "hello"
irb> x = 5
=> 5
irb> x = true
=> true
~~~

Note that you can assign and re-assign `x` to your heart's content and to
different types while you're at it. And you're at it.

Now is the time to start letting go of your _this is insane_ resistance.
Embrace it. When in Stockholm do like the Stockholmers do.

And as far as those single and double quotes go: 

~~~
irb> x = 2
=> 2
irb> "we were #{x}"
=> "we were 2"
irb> 'we were #{x}'
=> "we were \#{x}"
~~~

[String interpolation](https://en.wikipedia.org/wiki/String_interpolation) yes.

And sometimes variables are not so variable:

~~~
irb> X = 5
=> 5
irb> X = 6
(irb):5: warning: already initialized constant X
~~~

Capitalize your variable and it becomes _constant_: initialize it once and
never more.

A word on camels and snakes when naming variables or really anything. Use snake
case almost everywhere: `lowercase_words_separated_by_underscores`. Except
`ClassNames`, go for camel case there. Classes will be take their turn later.

# Control Structures

## Conditions and `if`

Here's the basic form:

~~~ruby
if condition
  do_something
end
~~~

So no parentheses (`(condition)`), no colon (`condition:`), no curly brackets
(`{ do_something }`). And `end` to end it.

The usual `else if` and `else` work like so:

~~~ruby
if condition
  do_something
elsif other_condition
  do_something_else
else
  final_thing_you_can_do
end
~~~

Conditions in `if` statements are expressions that evaluate to true or false.
So what all evaluates to true?

- all numbers (including `0`) are true
- all strings (including `''` -- the empty string) are true
- `nil` (yep, that's a null right there) is false
- the boolean literal `true` is true
- the boolean literal `false` is false
- the boolean expression `a && b` is true if `a` and `b` are true
- the boolean expression `a || b` is true if `a` or `b` are true
- the boolean expression `!a` is true if a is not true

Conditions can of course be the result of a function or method call which could
be true or false as well.

Your conditions will often compare things (if variable `a` is equal `"dog"`,
then do this). While you have `==`, `===`, `equal?`, and `eql?` in ruby, you
will mostly use:

- `==` for checking whether values are equal as far as the class designer of the objects you're comparing is concerned. 
- `equal?` for checking object equality.

In fact, `equal?` and `==` as defined in the
[`Object`](https://ruby-doc.org/core-3.0.2/Object.html#method-i-eql-3F) are
equal. Pun intended.

The intent is that `==` is overridden by class designers to something that
makes sense for your class, but that `equal?` always stands for object
equality. Take `String`:

~~~
irb> "a" == "a"
=> true
irb> "a".equal?("a")
=> false
~~~

So `"a"` is equal to `"a"` as values but as we saw before, they're not the same
objects. Looking at symbols:

~~~
irb> :a == :a
=> true
irb> :a.equal?(:a)
=> true
~~~

Back to our `if` for a bit. It's usual to instead of:

~~~ruby
if !condition
  do_something
end
~~~

to write:

~~~ruby
unless condition
  do_something
end
~~~

While this takes some getting used to, especially for my head, it's the ruby way.

Furthermore, if `do_something` is just one line, ruby often prefers the one-liner:

~~~ruby
do_something if condition
~~~

or

~~~ruby
do_something unless condition
~~~

Especially when returning early from functions, this makes code readable:

~~~ruby
return if invalid_parameters
~~~

## Looping

This is an area where ruby is opinionated. Say there's no collection like an
Array or Hash in sight, and in some other language (say `go`), we'd write:

~~~go
n := 5
for i := 0; i < n; i++ {
  fmt.Println(i)
}
~~~

This would print:

~~~
0
1
2
3
4
~~~

There's a variety of ways to write this in valid ruby, but the construct as
above does not exist.

Closest in spirit to the above one is to probably use a while:

~~~ruby
n = 5
i = 0
while i < n
  puts i
  i += 1
end
~~~

which is arguably slightly more verbose than the corresponding `for` loop in `go`.

A more ruby way is to probably use [`times`](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times):

~~~ruby
n.times { |i| puts i }
~~~

Now this is arguably quite elegant. But what's going on?

Let's analyze it's parts:

- `n`. An `Integer`, so an an object that has methods
- `times`. A [method](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times) that is called on the object and _iterates_ the following block `{ |i| puts i}` from `0` to `n - 1`, passing in those values to `i` with each iteration. Wow. More on blocks later. For those familiar, the block is essentially an anonymous function or lambda with parameter `i` (or arrow function for the Javascript knowledgeables). 
- `{ |i| puts i }`. We spoiled it, but this is a `block` that prints `i` with `i` ranging over values `0` to `n - 1`. This _feeding_ is accomplished by `times`. We'll see later how we can write functions such as `times` ourselves in the section on Blocks. For now, you can see `times` as an higher-order function that takes another function as an argument and executes. 

We'll do more looping in the Arrays and Hashes section, as most of the time
your looping will be in the context of some collection and also in that case
ruby has opinions.

# Arrays and Hashes

## Arrays

An array is an ordered collection of values. Let's initialize one:

~~~
irb> a = ["x", 1, :y]
=> ["x", 1, :y]
~~~

Arrays are in other words not restricted to 1 type of objects. You can shuffle
in there what'd you like. "Oh yeah??!!". Yes:

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
~~~

The usual suspects with a special mention for `-1` (the last of the elements):

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb> a.length
=> 3
irb> a[1]
=> [1, 2]
irb> a[-1]
=> :y
~~~

TODO:

- add elements front
- add elements back
- add another array
- destructive or not?



## Hashes

## Looping through Arrays and Hashes


# Functions

# Classes and Methods

# Modules

# Testing

# Blocks

Abandoning the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) to go a bit deeper into _blocks_.


# Conclusion


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

