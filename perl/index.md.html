
<meta charset="utf-8">
                            **WIP: Elements of Perl**
                            Stijn Heymans
                            Published: N/A
                            Revised: N/A

# Introduction

# Scalars

## Strings

### Basic Usage

Scalars or scalar values are typically the smallest unit of data type in perl, for example numbers and strings.

Generally, we'll store scalars in variables as follows:

~~~perl
my $var = 'I am a string';
~~~

The `my` in this part _declares_ the variable (similar to a `let` in
Javascript), and `$var` consists of the symbol `$` and the name `var`. The
latter is one of the things to get used to when switching from
python/javascript to perl, the symbol `$` hints at how the variable is used or accessed. In
this case, it declares and initializes a string, which is a scalar, and thus
the symbol `$` emphasizes that.

You'll later see symbols `@` for array usage and `%` for hash usage (a `hash`
is python's `dict` or generally a key-value structure such as a `Map` in Java).

Back to strings, you'll from to time want to concatenate 2 strings:

~~~perl
my $concat = $var . ' and me too.';
~~~

!!! note
   _statements_ in perl end with `;` as they do in Java or C++.


If you'd like to change `$var` by concatenating something to it, instead of `$var = $var . ' and me too.'` you can do:

~~~perl
$var .= ' and me too.';
~~~

You have spotted the single quotes for strings, and are wondering _what about
double quotes?_. You can use double quotes as well. Good practice is them only
when you want to _interpolate_ variables in them. For example:

~~~perl
my $name = 'stijn';
~~~

Interpolation will now make sure that `$name` in that `$hello` string is always
_expanded_ to its value. In this case, it will be `my name is stijn`.
Interpolation will usually lead to cleaner code than concatenation:

~~~perl
my $name = 'stijn';
my $hello = "my name is $name";
my $hello_conc = "my name is " . $name; 
~~~

Why is it good practice to only use them when you actually want to interpolate
variables? Imagine I have 

~~~perl
my $money = "my password is !$guest";
~~~

In this case `perl` will try to expand `$guest` which does not exist and will
result in warning and an unexpected result in `$money`.

You actually meant:

~~~perl
my $money = 'my password is !$guest';
~~~

You can get to individual characters of a string, as is expected from other languages:

~~~perl
my $string = 'what';
my $first = $string[0];
~~~

The kicker is to get the last character of the string:

~~~perl
my $last = $string[-1];
~~~

### Useful built-in Functions

#### [`print`](https://perldoc.perl.org/functions/print.html)

Printing to `STDOUT` will be mostly useful for debugging the odd statement here and there:

~~~perl
print "This is a printed string\n";
~~~

!!!
   There's an explicit `\n` in that statement; you might be used to a `println`
   from other languages that puts that `\n` there for you. But `perl` is not
   putting it there for you.

#### [`substr`](https://perldoc.perl.org/functions/substr.html)

Extract a substring out of a string. For example, to get a `cat` out of `concatenate`, do:

~~~perl
my $cat = substr('concatenate', 3, 3);
~~~

The first `3` is the offset from where to start the substring, the second `3`
is the length of the substring you want (_cat_ has 3 letters). You'll see this
pattern occur frequently, an _offset_ followed by a _length_ in the arguments
of a function.

If you leave off the length, you'll just take the substring until the end of
the string, for example to get `catenate`:

~~~perl
my $nonsense_substring = substr('concatenate', 3);
~~~

#### [`split`](https://perldoc.perl.org/functions/split.html)

Generally, allows to split a string into parts based on a regular expression
`/REGEXP/`. However, I will just mention the form you'll often spot in the
wild:

~~~perl
split //, 'yeah';
~~~

This will split the string `yeah` into its individual characters because the
pattern `//` matches _everything_ and returns a list of individual charactesr
(arrays follow later).

!!! 
   You'll have spotted `split //, 'yeah'` written without parenthesis. Based on
   how I wrote `substr` you expected to see `split(//,'yeah')` and you'd been
   right as well! `perl` is playing loose with parenthesis generally, so for
   built-in functions you'll often see parenthesis dropped. For functions you
   write yourself, I suggest to keep parenthesis when invoking them. Life is
   complicated enough as it is.


## Numbers

### Basic Usage

Let's dive into numbers.

~~~perl
my $numero = 42;
~~~

Easy enough. We can add numbers:

~~~perl
my $sum = $numero + 42;
~~~

which is of course the same as if we would have done:

~~~perl
my $doubling = 2 * $numero;
~~~

Similar like in other languages, there is a short hand for `$numero = $numero + 42`:

~~~perl
$numero += 42;
~~~

and similarly for other operations.

### Useful built-in Functions

I guess this is where I'd give a `sqrt` example, but how often have you used a
`sqrt` function in your professional code?

Oh, you can `print` them and a good conversion (the `%d` in the below template string) is...`%d`:

~~~perl
print "The meaning of life is %d", 42;
~~~

## `undef`

We talked about scalars like strings and numbers. But what about `null`? `null`
is a _thing_! Does `perl` has a `null`? Yes, it's `undef`. And where you'll see
in other languages a lot of null-checks, in `perl`, you'll see a lot of:

~~~perl
if (defined $x) {
  # stuff
}
~~~

which checks whether `$x` is defined (so is `undef` or not).

What's with the 

~~~perl
# stuff
~~~

You guessed it. `#` marks comments: anything
following it is ignored by the `perl` compiler.

# Array Variables

### Basic Usage

I get headaches when people start about an _array_ is this but a _list_ is
this. This is how you create an array of elements `I`, `do`, `not`, `care`:

~~~perl
my @array = ('I', 'do', 'not', 'care');
~~~

The crucial thing to note is the `@` here for the variable. In contrast to
other languages like Python or Javascript, `perl` gives you a queue on what
kind of variable something is. We already saw _scalar_ variables in which you
can store the lowest unit of _things_. The `@` signififies this is an _array_
variable and stores a _list of things_. And the wording of _things_ is
intentionaly. Array variables are list of _things_. So if a list contains a
variable, that variable will be a _scalar variable_.

I have find this probably the most confusing _thing_ (so I'd store my confusion
in a scalar).

Let's complicate this slightly more. Try getting the first element of the array `@array`:

~~~perl
my $first_element = $array[0];
~~~

The `[0]` part should look famililar, but note that it is `$array` when you use
`@array` to _access_ the scalar value at the first position (index `0`).

The last element is usually easily retrieved using the `-1` index:

~~~perl
my $last_element = $array[-1];
~~~

We can change an element similarly as retrieving. Change the first element of `@array`:

~~~perl
$array[0] = 'You';
~~~

I can copy an existing array `@array` to a new array `@copy`:

~~~perl
my @copy = @array;
~~~

Note that here I again use `@` for both: I'm creating an array `@copy` and
copying the array `@array` (I am not referring to the individual elements in
`@array`: the array is used in a _list_ context).

Note that this is indeed a copy: changing elements in `@copy` will _not_ change
elements in `@array`.

### Useful built-in Functions

#### Adding and Removing from an Array

##### At Back

##### At Front 

##### In Middle

#### Length of an Array with a detour to contexts

The length of an array is a funny thing. The notion of _context_ (briefly mentioned before) is important in `perl`. For example, assigning an array to a scalar variable, will cause the _length_ of that array to be assigned to the scalar. Indeed, you cannot store an array into a scalar, so what do you store? Well, a reasonable thing to store is the length of that array. So for this:

~~~perl
my @array = ('hey', 'you');
my $scalar_something = @array;
####

we have that `$scalar_something` now contains `2`: the length of `@array`. 


TODO: storing `undef` in an array.






# Hash Variables

# References

# Conditions

`if`, `grep`, and `any`, and `first`.

# Looping

## With `for`

## With `map`

# Subroutines

# Regular Expressions

We cannot talk about `perl` without regular expressions.

# Constants

I know you miss your `private static final` variables, my dear `java`
aficianado. For the rest of the world, constants, how do I declare something as
constant, you can't change it, don't touch it, don't even look at it!?



# Examples

# More

We skipped objects and so much more.

# Conclusion







<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
