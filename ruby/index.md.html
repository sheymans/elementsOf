<meta charset="utf-8">
                            **Elements of Ruby**
                            Stijn Heymans


# Introduction

I will attempt to introduce you to the elements of programming in
[Ruby](https://www.ruby-lang.org) from a beginner's mindset. I will assume you
can program in some other language (Java,
[Perl](http://www.stijnheymans.net/elements_of_perl.html), Python, whatever)
and so I'll not explain recursion, object-oriented programming, or other
concepts common to most programming languages.

I will mostly use 2 sources that were helpful to me and are worth digging into yourself:

- [Why's (Poignant) Guide to Ruby](https://poignant.guide/) by _why the lucky stiff_. That book is more art project than programming book, but it's also the one beginner's resource I found that gives an elemental overview of the language _with_ intuition of why things are the way they are in Ruby. If you already read that book, you can stop reading this article. You will not learn anything more than you already know.

- [Eloquent Ruby](https://www.goodreads.com/book/show/9364729-eloquent-ruby) by Russ Olsen. This takes things a step further and highlights the _Ruby_ way of doing common tasks, but also goes into meta-programming with Ruby that is easy to understand and gives you an inkling why Ruby might be different than some of the other languages out there.

Finally, and the source that stands a bit out, I will follow a structure that is
loosely inspired by the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) by Caleb
Doxsey. It's a great little book on Go, but most of all it's a great little
_short_ book on Go that manages to bring the basics across without decorum.
Something I aspire to in this article. Let's try.

# Getting Started

I assume you have some familiarity with basic command-line usage. Check whether
ruby is installed:

~~~shell
$ ruby --version
~~~

For me, it returns `ruby 2.6.3p62 (2019-04-16 revision 67580)
[universal.x86_64-darwin20]`). If you don't have it installed, you can get it
at [the ruby-lang website](https://www.ruby-lang.org/en/downloads/).

If you have ruby, you will have an interactive interpreter called
[irb](https://github.com/ruby/irb). On the command-line, type `irb`.

~~~
irb> puts 'Hello World!'
Hello World!
=> nil
~~~

Leave the interactive interpreter `irb` by typing `exit`. Now the same but
without `irb`. Open a file (make it end on `rb`, for example
`ruby_playground.rb`) and put the following line in it:

~~~ruby
puts 'Hello World!'
~~~

Close the file and at the command-line, have ruby execute it:

~~~
$ ruby ruby_playground.rb
Hello World!
~~~

Want to know more about `puts`? Get in the habit of looking that sort of info
up in the [official docs](https://docs.ruby-lang.org/en/) -
pick the right version of the docs corresponding to what you saw in your
initial `ruby --version`. I picked `2.6.0` as my ruby version is `2.6.3`.

This got us started.

# The Basic Classes

## Numbers

Unsuprisingly, integers are represented as we expect: `3`, `5, `-100`, ...
Suprisingly, everything in ruby is an object so you can ask the class of an
integer by doing `5.class`, which will return
[Integer](https://docs.ruby-lang.org/en/2.6.0/Integer.html). 

Since they're full-fledged objects there's more fun stuff one can do: 

~~~
irb> 123.digits
=> [3, 2, 1]
~~~

Yep, you can get an array of all digits that make up the integer. Fans of
coding interviews will like that, cause that's literally the only place you'll
ever need that.

You can do the usual math:

~~~
irb> 1 + 2
=> 3
irb> 2 * 3
=> 6
irb> 8 / 4
=> 2
~~~

Besides integers, you have our favorite inexact real numbers, represented by
[Float](https://docs.ruby-lang.org/en/2.6.0/Float.html) and in its literal form
things containing a decimal point:`1.0`, `9.9999`, ...

~~~
irb> 1.0.class
=> Float
~~~

First encounters are often unpleasant:

~~~
irb> 7 / 2
=> 3
~~~

Dividing 2 integers results in integer division. Force one to be a `Float`
using `to_f`:

~~~
irb> 7.to_f / 2
=> 3.5
~~~

## Strings

String are any characters surrounded by single quotes or double quotes:
`'Hello'` or `"Hello"`. The double-quoted variety are a bit special. I'll show
after talking about variables.

## Symbols

Symbols consist of letters, digits, or underscores, and are preceded by a `:`.
For example, `:a`, `:a_2`, `:an_orange`. Well, why not just use Strings? [Great
question](https://stackoverflow.com/questions/255078/whats-the-difference-between-a-string-and-a-symbol-in-ruby).

Remember that I said everything is an object? So let's look a bit at how strings are different from objects:

~~~
irb> "bar".object_id
=> 70236502854760
irb> "bar".object_id
=> 70236502887440
irb> :foo.object_id
=> 1516508
irb> :foo.object_id
=> 1516508
~~~

You can learn several things from this:

- every object apparently has a method `object_id` that gives some sort of id.
- strings that look the same do not necessarily have the same `object_id`, which _probably_ has memory consequences
- symbols that look the same have the same `object_id`, which _probably_ has memory consequences

## Booleans

`true` and `false`. There.


# Variables

Like symbols they consist of letters, digits, or underscores. Unlike symbols,
they do not start with colons. You initialize them:

~~~
irb> x = 'hello'
=> "hello"
irb> x = 5
=> 5
irb> x = true
=> true
~~~

Note that you can assign and re-assign `x` to your heart's content and to
different types while you're at it. And you're at it.

Now is the time to start letting go of your _this is insane_ resistance.
Embrace it. When in Stockholm do like the Stockholmers do.

And as far as those single and double quotes go: 

~~~
irb> x = 2
=> 2
irb> "we were #{x}"
=> "we were 2"
irb> 'we were #{x}'
=> "we were \#{x}"
~~~

[String interpolation](https://en.wikipedia.org/wiki/String_interpolation) yes.

And sometimes variables are not so variable:

~~~
irb> X = 5
=> 5
irb> X = 6
(irb):5: warning: already initialized constant X
~~~

Capitalize your variable and it becomes _constant_: initialize it once and
never more.

A word on camels and snakes when naming variables or really anything. Use snake
case almost everywhere: `lowercase_words_separated_by_underscores`. Except
`ClassNames`, go for camel case there. Classes will be take their turn later.

# Control Structures

## Conditions and `if`

Here's the basic form:

~~~ruby
if condition
  do_something
end
~~~

So no parentheses (`(condition)`), no colon (`condition:`), no curly brackets
(`{ do_something }`). And `end` to end it.

The usual `else if` and `else` work like so:

~~~ruby
if condition
  do_something
elsif other_condition
  do_something_else
else
  final_thing_you_can_do
end
~~~

Conditions in `if` statements are expressions that evaluate to true or false.
So what all evaluates to true?

- all numbers (including `0`) are true
- all strings (including `''` -- the empty string) are true
- `nil` (yep, that's a null right there) is false
- the boolean literal `true` is true
- the boolean literal `false` is false
- the boolean expression `a && b` is true if `a` and `b` are true
- the boolean expression `a || b` is true if `a` or `b` are true
- the boolean expression `!a` is true if a is not true

Conditions can of course be the result of a function or method call which could
be true or false as well.


todo: comparison operators

todo: unless

todo: short form

## Looping

# Arrays and Hashes


todo: loop through arrrays and hashes

# Functions

# Classes and Methods

# Modules

# Testing

# Blocks

Abandoning the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) to go a bit deeper into _blocks_.


# Conclusion


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

