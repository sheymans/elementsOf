
<meta charset="utf-8">
                            **WIP: Elements of Perl**
                            Stijn Heymans
                            Published: N/A
                            Revised: N/A

# Introduction

# Scalars

## Strings

### Basic Usage

Scalars or scalar values are typically the smallest unit of data type in perl, for example numbers and strings.

Generally, we'll store scalars in variables as follows:

~~~perl
my $var = 'I am a string';
~~~

The `my` in this part _declares_ the variable (similar to a `let` in
Javascript), and `$var` consists of the symbol `$` and the name `var`. The
latter is one of the things to get used to when switching from
python/javascript to perl, the symbol `$` hints at how the variable is used or accessed. In
this case, it declares and initializes a string, which is a scalar, and thus
the symbol `$` emphasizes that.

You'll later see symbols `@` for array usage and `%` for hash usage (a `hash`
is python's `dict` or generally a key-value structure such as a `Map` in Java).

Back to strings, you'll from to time want to concatenate 2 strings:

~~~perl
my $concat = $var . ' and me too.';
~~~

!!! note
   _statements_ in perl end with `;` as they do in Java or C++.


If you'd like to change `$var` by concatenating something to it, instead of `$var = $var . ' and me too.'` you can do:

~~~perl
$var .= ' and me too.';
~~~

You have spotted the single quotes for strings, and are wondering _what about
double quotes?_. You can use double quotes as well. Good practice is them only
when you want to _interpolate_ variables in them. For example:

~~~perl
my $name = 'stijn';
~~~

Interpolation will now make sure that `$name` in that `$hello` string is always
_expanded_ to its value. In this case, it will be `my name is stijn`.
Interpolation will usually lead to cleaner code than concatenation:

~~~perl
my $name = 'stijn';
my $hello = "my name is $name";
my $hello_conc = "my name is " . $name; 
~~~

Why is it good practice to only use them when you actually want to interpolate
variables? Imagine I have 

~~~perl
my $money = "my password is !$guest";
~~~

In this case `perl` will try to expand `$guest` which does not exist and will
result in warning and an unexpected result in `$money`.

You actually meant:

~~~perl
my $money = 'my password is !$guest';
~~~

You can get to individual characters of a string, as is expected from other languages:

~~~perl
my $string = 'what';
my $first = $string[0];
~~~

The kicker is to get the last character of the string:

~~~perl
my $last = $string[-1];
~~~

### Useful built-in Functions

#### [`print`](https://perldoc.perl.org/functions/print.html)

Printing to `STDOUT` will be mostly useful for debugging the odd statement here and there:

~~~perl
print "This is a printed string\n";
~~~

!!!
   There's an explicit `\n` in that statement; you might be used to a `println`
   from other languages that puts that `\n` there for you. But `perl` is not
   putting it there for you.

#### [`substr`](https://perldoc.perl.org/functions/substr.html)

Extract a substring out of a string. For example, to get a `cat` out of `concatenate`, do:

~~~perl
my $cat = substr('concatenate', 3, 3);
~~~

The first `3` is the offset from where to start the substring, the second `3`
is the length of the substring you want (_cat_ has 3 letters). You'll see this
pattern occur frequently, an _offset_ followed by a _length_ in the arguments
of a function.

If you leave off the length, you'll just take the substring until the end of
the string, for example to get `catenate`:

~~~perl
my $nonsense_substring = substr('concatenate', 3);
~~~

#### [`split`](https://perldoc.perl.org/functions/split.html)

Generally, allows to split a string into parts based on a regular expression
`/REGEXP/`. However, I will just mention the form you'll often spot in the
wild:

~~~perl
split //, 'yeah';
~~~

This will split the string `yeah` into its individual characters because the
pattern `//` matches _everything_ and returns a list of individual charactesr
(arrays follow later).

!!! 
   You'll have spotted `split //, 'yeah'` written without parenthesis. Based on
   how I wrote `substr` you expected to see `split(//,'yeah')` and you'd been
   right as well! `perl` is playing loose with parenthesis generally, so for
   built-in functions you'll often see parenthesis dropped. For functions you
   write yourself, I suggest to keep parenthesis when invoking them. Life is
   complicated enough as it is.


## Numbers

### Basic Usage

Let's dive into numbers.

~~~perl
my $numero = 42;
~~~

Easy enough. We can add numbers:

~~~perl
my $sum = $numero + 42;
~~~

which is of course the same as if we would have done:

~~~perl
my $doubling = 2 * $numero;
~~~

Similar like in other languages, there is a short hand for `$numero = $numero + 42`:

~~~perl
$numero += 42;
~~~

and similarly for other operations.

### Useful built-in Functions

I guess this is where I'd give a `sqrt` example, but how often have you used a
`sqrt` function in your professional code?

Oh, you can `print` them and a good conversion (the `%d` in the below template string) is...`%d`:

~~~perl
print "The meaning of life is %d", 42;
~~~

## `undef`

We talked about scalars like strings and numbers. But what about `null`? `null`
is a _thing_! Does `perl` has a `null`? Yes, it's `undef`. And where you'll see
in other languages a lot of null-checks, in `perl`, you'll see a lot of:

~~~perl
if (defined $x) {
  # stuff
}
~~~

which checks whether `$x` is defined (so is `undef` or not).

What's with the 

~~~perl
# stuff
~~~

You guessed it. `#` marks comments: anything
following it is ignored by the `perl` compiler.

# Array Variables

## Basic Usage

I get headaches when people start about an _array_ is this but a _list_ is
this. This is how you create an array of elements `I`, `do`, `not`, `care`:

~~~perl
my @array = ('I', 'do', 'not', 'care');
~~~

The crucial thing to note is the `@` here for the variable. In contrast to
other languages like Python or Javascript, `perl` gives you a queue on what
kind of variable something is. We already saw _scalar_ variables in which you
can store the lowest unit of _things_. The `@` signififies this is an _array_
variable and stores a _list of things_. And the wording of _things_ is
intentionaly. Array variables are list of _things_. So if a list contains a
variable, that variable will be a _scalar variable_.

I have find this probably the most confusing _thing_ (so I'd store my confusion
in a scalar).

Let's complicate this slightly more. Try getting the first element of the array `@array`:

~~~perl
my $first_element = $array[0];
~~~

The `[0]` part should look famililar, but note that it is `$array` when you use
`@array` to _access_ the scalar value at the first position (index `0`).

The last element is usually easily retrieved using the `-1` index:

~~~perl
my $last_element = $array[-1];
~~~

We can change an element similarly as retrieving. Change the first element of `@array`:

~~~perl
$array[0] = 'You';
~~~

I can copy an existing array `@array` to a new array `@copy`:

~~~perl
my @copy = @array;
~~~

Note that here I again use `@` for both: I'm creating an array `@copy` and
copying the array `@array` (I am not referring to the individual elements in
`@array`: the array is used in a _list_ context).

Note that this is indeed a copy: changing elements in `@copy` will _not_ change
elements in `@array`.

## Useful built-in Functions

### Adding and Removing from Back of an Array


You can remove elements from the back/end of an array, using [`pop`](https://perldoc.perl.org/functions/pop.html):

~~~perl
my @array = (4, 5);
my $last = pop @array;
~~~

Note that we did not write `pop(@array)` as `pop` is a built-in. What will
`$last` store? It'll store the last element of `@array`: `5`. What will
`@array` store? An array with the last element removed: `(4)`.

You can add it back by adding it end of array using [`push`](https://perldoc.perl.org/functions/pop.html):

~~~perl
push @array, 5;
~~~

Then, `@array` will be `(4, 5)` again. You can also use `push` to append a list:

~~~perl
push @array, (4, 5);
~~~

### Adding and Removing from Front of an Array

Sometimes you'd want to add something to the front of an array, and we use the
very memorizable [`unshift`](https://perldoc.perl.org/functions/unshift.html)
for that:

~~~perl
unshift @array, 4;
~~~

This adds `4` to the front of `@array`. Note that you can also pre-pend lists like that:

~~~perl
unshift @array, (4, 5)
~~~

This turns for example, `(6, 7)` into `(4, 5, 6, 7)`. Note that the order is
preserved (so it does not loop through `(4, 5)` and adds the elements one by
one)

Similar to how `pop` removes from the back of the list, we have a function to remove something from the start of the list:

~~~perl
my $first = shift @array;
~~~

`@array` will be modified after this: the first element is removed and in this
case we stored it in `$first`. You can imagine
[`shift`](https://perldoc.perl.org/functions/shift.html) as shifting the array
to the left and thus dropping of the first element.

### Length of an Array with a detour to contexts

The length of an array is a funny thing. The notion of _context_ (briefly
mentioned before) is important in `perl`. For example, assigning an array to a
scalar variable, will cause the _length_ of that array to be assigned to the
scalar. Indeed, you cannot store an array into a scalar, so what do you store?
Well, a reasonable thing to store is the length of that array. So for this:

~~~perl
my @array = ('hey', 'you');
my $scalar_something = @array;
~~~

we have that `$scalar_something` now contains `2`: the length of `@array`. 

This also works the other way: what if you want to store a scalar into a list?
For example:

~~~perl
my $scalar = 'a';
my @array = $scalar;
~~~

You're now trying to store a scalar variable `$scalar` into an array variable,
or in other words, into a _list context_. `perl` will try to make a list out of
the scalar, and the natural way to do so is by treating your scalar as a list
with 1 element in it (the scalar). So `@array` will effectively be the list
`('a')`.


# Hash Variables

# References

# Conditions

`if`, `grep`, and `any`, and `first`.

# Looping

## With `for`

## With `map`

# Subroutines

TODO: talk about call by value for functions (can I change arguments: yes, if I use references)

TODO: talk about why you will see `my $first = shift` without arguments for shift (cause it uses `@_` by default).

# Regular Expressions

We cannot talk about `perl` without regular expressions.

# Constants

I know you miss your `private static final` variables, my dear `java`
aficianado. For the rest of the world, constants, how do I declare something as
constant, you can't change it, don't touch it, don't even look at it!?


# Examples

# More

We skipped objects and so much more.

# Conclusion


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
