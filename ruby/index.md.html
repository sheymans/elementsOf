<meta charset="utf-8">
                            **Elements of Ruby**
                            Stijn Heymans
                            published: 1 December 2021

# Introduction

I will introduce you to the elements of programming in
[Ruby](https://www.ruby-lang.org). I assume you can program in some other
language such as Java,
[Perl](http://www.stijnheymans.net/elements_of_perl.html), Python, Go, ...

Background sources that were helpful to me:

- [Why's (Poignant) Guide to Ruby](https://poignant.guide/) by _why the lucky
  stiff_. More art project than programming book, but a beginner's resource
  that gives an elemental overview of the language _with_ intuition of the Ruby
  language.  If you read that book, you can stop reading this article. There's
  nothing here for you.

- [Eloquent Ruby](https://www.goodreads.com/book/show/9364729-eloquent-ruby) by
  Russ Olsen. A bit more advanced than _Why's (Poignant) Guide to Ruby_. The
  book ventures into meta-programming with Ruby. To see what sets Ruby apart, I
  recommend this book.

In this article, I will follow a structure that is loosely inspired by the
structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) by Caleb
Doxsey. Not a Ruby book, but a Go, book. It's a _short_ book on Go that manages
to bring the basics across.  Something I will aspire to in this article, for
Ruby.

# Getting Started

On the command-line, check whether Ruby is installed:

~~~shell
$ ruby --version
~~~

For me, this shows `ruby 2.6.3p62 (2019-04-16 revision 67580)
[universal.x86_64-darwin20]`). If you don't have Ruby installed, get it at [the
ruby-lang website](https://www.ruby-lang.org/en/downloads/).

If you have Ruby installed, you also have an interactive interpreter called
[irb](https://github.com/ruby/irb). On the command-line, type `irb`.

~~~
irb> puts 'Hello World!'
Hello World!
=> nil
~~~

Leave the interactive interpreter `irb` by typing `exit`. Now let's a `Hello World!` again, but
without `irb`. Open a file (make it end on `rb`, for example
`ruby_playground.rb`) and write the following line in it:

~~~ruby
puts 'Hello World!'
~~~

Close the file and at the command-line, have Ruby execute it:

~~~
$ ruby ruby_playground.rb
Hello World!
~~~

Do you want to know more about `puts`? Get in the habit of using the [official
docs](https://docs.ruby-lang.org/en/).  Pick the right version of the docs
corresponding to what you saw in your initial `ruby --version`. I picked
`2.6.0` as my Ruby version is `2.6.3` and found this
[explanation](https://docs.ruby-lang.org/en/2.6.0/ARGF.html#method-i-puts).

# The Basic Classes

## Numbers

Unsurprisingly, integers are represented as we expect: `3`, `5`, `-100`, ...
Surprisingly, everything in Ruby is an object so you can ask the class of an
integer: `5.class`. This returns
[Integer](https://docs.ruby-lang.org/en/2.6.0/Integer.html). 

Since integers are objects there's more fun stuff one can ask them: 

~~~
irb> 123.digits
=> [3, 2, 1]
~~~

Fans of coding interviews will appreciate this. That's the only place you will
ever need that.

Simple math is ready for you and has been since you were 7:

~~~
irb> 1 + 2
=> 3
irb> 2 * 3
=> 6
irb> 8 / 4
=> 2
~~~

There's also the number type that keeps it real and inexact, le
[Float](https://docs.ruby-lang.org/en/2.6.0/Float.html). In its literal
representation, it's _things_ that contain a decimal point:`1.0`, `9.9999`, ...

~~~
irb> 1.0.class
=> Float
~~~

First encounters are frequently unpleasant:

~~~
irb> 7 / 2
=> 3
~~~

Dividing 2 integers results in integer division. Force one to be a `Float`
using `to_f`:

~~~
irb> 7.to_f / 2
=> 3.5
~~~

## Strings

String are characters surrounded by single quotes or double quotes: `'Hello'`
or `"Hello"`. The double-quoted variety is special. More later. Be patient.

Use `+` to concatenate 2 strings without changing the original strings. Use
`<<` to concanate and destroy the string you're appending to:

~~~
irb> a = "hello"
=> "hello"
irb> b = "world"
=> "world"
irb> a + b
=> "helloworld"
irb> a
=> "hello"
irb> b
=> "world"
irb> a << b
=> "helloworld"
irb> a
=> "helloworld"
irb> b
=> "world"
~~~

Pull characters out of a String:

~~~
irb> a = "hello"
=> "hello"
irb> a[0]
=> "h"
irb> a[-1]
=> "o"
~~~

You can get substrings by using inclusive (`..`) or exclusive (`...`) ranges:

~~~
irb> a = "hello"
=> "hello"
irb> a[0..2]
=> "hel"
irb> a[0...2]
=> "he"
~~~

## Symbols

Symbols consist of letters, digits, or underscores, and are preceded by a `:`.
For example, `:a`, `:a_2`, `:an_orange`. Why not just use Strings? [Great
question](https://stackoverflow.com/questions/255078/whats-the-difference-between-a-string-and-a-symbol-in-ruby).

Remember that I said everything is an object? So let's look a bit at how strings are different from symbols by looking at their `object_id`:

~~~
irb> "bar".object_id
=> 70236502854760
irb> "bar".object_id
=> 70236502887440
irb> :foo.object_id
=> 1516508
irb> :foo.object_id
=> 1516508
~~~

You can learn several things from this:

- every object apparently has a method `object_id` that gives some sort of id.
- strings that look the same do not necessarily have the same `object_id`, which _probably_ has memory consequences
- symbols that look the same have the same `object_id`, which _probably_ has memory consequences

## Booleans

`true` and `false`. There.


# Variables

Like symbols they consist of letters, digits, or underscores. Unlike symbols,
they do not start with colons. You initialize them:

~~~
irb> x = 'hello'
=> "hello"
irb> x = 5
=> 5
irb> x = true
=> true
~~~

Note that you can assign and re-assign `x` to your heart's content and to
different types while you're at it. And you're at it.

Now is the time to start letting go of your _this is insane_ resistance.
Embrace it. When in Stockholm do like the Stockholmers do.

And as far as those single and double quotes go: 

~~~
irb> x = 2
=> 2
irb> "we were #{x}"
=> "we were 2"
irb> 'we were #{x}'
=> "we were \#{x}"
~~~

[String interpolation](https://en.wikipedia.org/wiki/String_interpolation) yes.

And sometimes variables are not so variable:

~~~
irb> X = 5
=> 5
irb> X = 6
(irb):5: warning: already initialized constant X
~~~

Capitalize your variable and it becomes _constant_: initialize it once and
never more.

A word on camels and snakes when naming variables or really anything. Use snake
case almost everywhere: `lowercase_words_separated_by_underscores`. Except
`ClassNames`, go for camel case there. Classes will be take their turn later.

# Control Structures

## Conditions and `if`

Here's the basic form:

~~~ruby
if condition
  do_something
end
~~~

So no parentheses (`(condition)`), no colon (`condition:`), no curly brackets
(`{ do_something }`). And `end` to end it.

The usual `else if` and `else` work like so:

~~~ruby
if condition
  do_something
elsif other_condition
  do_something_else
else
  final_thing_you_can_do
end
~~~

Conditions in `if` statements are expressions that evaluate to true or false.
So what all evaluates to true?

- all numbers (including `0`) are true
- all strings (including `''` -- the empty string) are true
- `nil` (yep, that's a null right there) is false
- the boolean literal `true` is true
- the boolean literal `false` is false
- the boolean expression `a && b` is true if `a` and `b` are true
- the boolean expression `a || b` is true if `a` or `b` are true
- the boolean expression `!a` is true if a is not true

Conditions can of course be the result of a function or method call which could
be true or false as well.

Your conditions will often compare things (if variable `a` is equal `"dog"`,
then do this). While you have `==`, `===`, `equal?`, and `eql?` in Ruby, you
will mostly use:

- `==` for checking whether values are equal as far as the class designer of the objects you're comparing is concerned. 
- `equal?` for checking object equality.

In fact, `equal?` and `==` as defined in the
[`Object`](https://ruby-doc.org/core-3.0.2/Object.html#method-i-eql-3F) are
equal. Pun intended.

The intent is that `==` is overridden by class designers to something that
makes sense for your class, but that `equal?` always stands for object
equality. Take `String`:

~~~
irb> "a" == "a"
=> true
irb> "a".equal?("a")
=> false
~~~

So `"a"` is equal to `"a"` as values but as we saw before, they're not the same
objects. Looking at symbols:

~~~
irb> :a == :a
=> true
irb> :a.equal?(:a)
=> true
~~~

Back to our `if` for a bit. It's usual to instead of:

~~~ruby
if !condition
  do_something
end
~~~

to write:

~~~ruby
unless condition
  do_something
end
~~~

While this takes some getting used to, especially for my head, it's the Ruby way.

Furthermore, if `do_something` is just one line, Ruby often prefers the one-liner:

~~~ruby
do_something if condition
~~~

or

~~~ruby
do_something unless condition
~~~

Especially when returning early from functions, this makes code readable:

~~~ruby
return if invalid_parameters
~~~

## Looping

This is an area where Ruby is opinionated. Say there's no collection like an
Array or Hash in sight, and in some other language (say `go`), we'd write:

~~~go
n := 5
for i := 0; i < n; i++ {
  fmt.Println(i)
}
~~~

This would print:

~~~
0
1
2
3
4
~~~

There's a variety of ways to write this in valid Ruby, but the construct as
above does not exist.

Closest in spirit to the above one is to probably use a while:

~~~ruby
n = 5
i = 0
while i < n
  puts i
  i += 1
end
~~~

which is arguably slightly more verbose than the corresponding `for` loop in `go`.

A more Ruby way is to probably use [`times`](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times):

~~~ruby
n.times { |i| puts i }
~~~

Now this is arguably quite elegant. But what's going on?

Let's analyze it's parts:

- `n`. An `Integer`, so an an object that has methods
- `times`. A [method](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times) that is called on the object and _iterates_ the following block `{ |i| puts i}` from `0` to `n - 1`, passing in those values to `i` with each iteration. Wow. More on blocks later. For those familiar, the block is essentially an anonymous function or lambda with parameter `i` (or arrow function for the Javascript knowledgeables). 
- `{ |i| puts i }`. We spoiled it, but this is a `block` that prints `i` with `i` ranging over values `0` to `n - 1`. This _feeding_ is accomplished by `times`. We'll see later how we can write functions such as `times` ourselves in the section on Blocks. For now, you can see `times` as an higher-order function that takes another function as an argument and executes. 

We'll do more looping in the Arrays and Hashes section, as most of the time
your looping will be in the context of some collection and also in that case
Ruby has opinions.

# Arrays and Hashes

## Arrays

An array is an [ordered integer-indexed collection](https://docs.ruby-lang.org/en/2.6.0/Array.html) of objects. Let's initialize one:

~~~
irb> a = ["x", 1, :y]
=> ["x", 1, :y]
~~~

Arrays are in other words not restricted to 1 type of objects. You can shuffle
in there what you like. "Oh yeah??!!". Yes:

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
~~~

The usual suspects with a special mention for `-1` (the last of the elements):

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb> a.length
=> 3
irb> a[1]
=> [1, 2]
irb> a[-1]
=> :y
~~~

You can add elements to the back of an array using `<<` or `push`. Both are destructive operations:

~~~
irb> a << :b
=> ["x", [1, 2], :y, :b]
irb> a.push(:c)
=> ["x", [1, 2], :y, :b, :c]
irb> a
=> ["x", [1, 2], :y, :b, :c]
~~~

You can remove that last element again using `pop`:

~~~
irb> l = a.pop
=> :c
irb> a
=> ["x", [1, 2], :y, :b]
~~~

What about adding and removing to the _front_ of an array? Use `unshift` and `shift`. As far as unsavory mnemonics go, remove the `f` to remember which does what.

~~~
irb> a
=> ["x", [1, 2], :y, :b]
irb> f = a.shift
=> "x"
irb> a
=> [[1, 2], :y, :b]
irb> a.unshift("x_new")
=> ["x_new", [1, 2], :y, :b]
~~~

But `pop/push` must be more efficient than `shift/unshift` right? Seems [it
hardly
matters](https://stackoverflow.com/questions/8353026/what-is-the-run-time-of-shift-unshift-in-a-ruby-array).

What if you have a second array `b = [:b1, :b2]` that you want to append (i.e., add each element) to `a`? Just using `push` will not do what you want:

~~~
irb(main):019:0> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb(main):020:0> b = [:b1, :b2]
=> [:b1, :b2]
irb(main):021:0> a.push(b)
=> ["x", [1, 2], :y, [:b1, :b2]]
~~~

However, using the _splat_ operator `*` will:

~~~
irb> b = [:b1, :b2]
=> [:b1, :b2]
irb> a.push(*b)
=> ["x", [1, 2], :y, :b1, :b2]
~~~

`*b` for an array `b` in the context of a function call (`push` here) will send
each element of the array as an individual argument to the function. In other
words, `a.push(*b)` is the same as `a.push(:b1, :b2)`.

So far we initialized arrays using their literal form (such as `a = [1, 2]`).
We can also initialize them using the `new` method from the
[Array](https://docs.ruby-lang.org/en/2.6.0/Array.html) class:

~~~
irb> a = Array.new
=> []
irb> a << 1
=> [1]
~~~

## Hashes

[Hashes](https://docs.ruby-lang.org/en/2.6.0/Hash.html) are structures to store
key-value pairs with unique keys (also called dictionaries, associate arrays,
`HashMap`, maps in other languages). You can use any object type as a key.

Define a hash with some personal information and do some basics like getting a value for an existing key, a non-existing key, changing a value for an existing key, adding a value for a non-existing key, and removing a key/value pair:

~~~
irb> a = { "first" => "John", "last" => "Doe" }
=> {"first"=>"John", "last"=>"Doe"}
irb> a["first"]
=> "John"
irb> a["nothere"]
=> nil
irb> a["first"] = "Jane"
=> "Jane"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
irb> a["first"]
=> "Jane"
irb> a["nothere"] = "now it is here"
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe", "nothere"=>"now it is here"}
irb> a.delete("nothere")
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
~~~

What type of objects can all be values? Any object.

What type of objects can all be keys, surely only Strings right? Any object.

Let's start with showing symbols as keys as there's some syntactic sugar for those.

~~~
irb> a = { :first => "John", :last => "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a[:first]
=> "John"
~~~

Nothing interesting happened. You used symbols `:first` and `:last` as keys. If
you do that, you can get all JSON-y instead:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
~~~

Same hot sauce though.

I confidently said you can use any object as a hash key. You can both in order
to have certain expectations met (like: if the objects are the "same", only 1
hash key that is that object should be in your hash). This relies on properly
overriding `hash` and `eql?` (the latter being what
[Hash](https://docs.ruby-lang.org/en/2.6.0/Hash.html) uses for testing equality
of keys. [Two objects will then refer to the same key when their `hash` value
is identical and the 2 objects `eql?` each
other](https://docs.ruby-lang.org/en/2.6.0/Hash.html#class-Hash-label-Hash+Keys).
Is this still elemental? Probably not. Moving on.

## Looping through Arrays and Hashes

You will spend half of your life looping through arrays and hashes. Say you have an array:

~~~
a = [100, 200, 300]
~~~

Let's print each element.

~~~
a.each { |el| puts el }
~~~

No `for` in sight. Use `each` when you can. `each` iterates through the
elements of the array and binds each to _el_ in the block `{ |el| puts el }`,
and then executes the `puts el`. Often you'll do more than a one-liner, and
you'll use the `do` variety:

~~~ruby
a.each do |el|
  puts el
  puts el
end
~~~

Same thing, but you use `do...end`

Sometimes you will want the index as well. So similar to the trickery we saw before you could do:

~~~ruby
a.length.times { |i| puts a[i] }
~~~

That works obviously as computers do not have opinions. More idiomatic as far
as I could tell is to use `each_with_index`. Let's also throw that string
interpolation in the mix:

~~~
irb> a.each_with_index { |el, i| puts "#{i}: #{el}" }
0: 100
1: 200
2: 300
~~~

Yeah, get those [Anki flashcards](https://apps.ankiweb.net/) out to memorize
the order of that `|el, i|`. Alternatively, in Ruby syntax, it often works to
think "how would I say this out loud?": in the array `a`, for _each_ `el` at
index `i`, do something. If you naturally go to _for each index `i` which has
element `el`_ you're on your own in this mess, my friend.

You can loop over a hash with `each` as well:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> John
last -> Doe
~~~

This should not be surprising. In case you want to see just the keys of a hash, you have

~~~
irb> a.keys
=> [:first, :last]
~~~

And similarly for the values in a hash:

~~~
irb> a.values
=> ["John", "Doe"]
~~~

In contrast to usual hashes (e.g., in Java), you _can_ assume an order on key-value pairs in Ruby. They will be in the order they were inserted:

~~~
irb> a = {}
=> {}
irb> a["first"] = 1
=> 1
irb> a["second"] = 2
=> 2
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> 1
second -> 2
~~~

Sometimes you can benefit from going one abstraction higher than pure looping, and use a [`map`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map):

~~~
irb> a = [1, 2, 3]
=> [1, 2, 3]
irb> b = a.map { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [1, 2, 3]
~~~

If you do not want a new array, you can use the [destructive variant
`map!`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map-21):

~~~
irb> a.map! { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [2, 4, 6]
~~~

The convention in Ruby is to indeed append `!` to function names if those
functions are supposed to be destructive.

We can also map hashes. For example, collect all keys of a map, but uppercased:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.map { |key, value| key.upcase }
=> [:FIRST, :LAST]
~~~

Instead of that 1 value in the block arguments, we have 2: `|key, value|` as we're dealing with a Hash. We map that key-value pair to `key.upcase`, and `map` collects those in an Array. What if you want to map a Hash to a Hash, but just keeping the keys but uppercasing the values:

~~~
irb> a.map { |key, value| [key, value.upcase] }.to_h
=> {:first=>"JOHN", :last=>"DOE"}
~~~

The tricky part is that the `map` gives us an array of `[key, value.upcase]`
arrays. So we use `to_h` to convert that very specific array to a hash.
Generally:

~~~
irb> [[1, 2], [3, 4]].to_h
=> {1=>2, 3=>4}
~~~

We're verging to the non-elemental, so moving on.

# Functions

Your first unit of abstraction are functions (or _methods_, when appearing in classes, same potato). Functions take the following shape:

~~~ruby
def function_name(arg1, arg2,...)
  # do stuff
end
~~~

Functions start with `def` and end with `end`. A function that doubles an array `a`:

~~~ruby
def double_all(a)
  a.map { |x| x * 2 }
end
~~~

"Oh no," you may say. "They forgot to type the arguments, what a nightmare to
read code like that,". Yes, but embrace it. Essentially, your `a` can be
anything as long as it understands `map`. Yes, yes, interfaces and all. 

Calling functions is as you would expect:

~~~
irb> a = [1, 2, 3]
irb> puts double_all(a)
2
4
6
~~~


You have options if you do not want to embrace it. Check out
[sorbet](https://sorbet.org/) which allows you to annotate your functions with
type information. For example, the above would be intended for:

~~~ruby
sig { params(a: T::Array[Integer].returns(T::Array[Integer]) }
def double_all(a)
  a.map { |x| x * 2 }
end
~~~

You can have defaults for your arguments:

~~~ruby
def double_all(a = [1, 2])
  a.map { |x| x * 2 }
end
~~~

You can then just do:

~~~
irb> puts double_all
2
4
~~~

You can have of courses have a hash as an argument:

~~~ruby
def hash_keys(h)
  puts "a: #{h[:a]}"
  puts "b: #{h[:b]}"
end
~~~

And then:

~~~
irb> puts hash_keys({ a: 1, b: 2 })
a: 1
b: 2
~~~

Here's some fun. If a hash is the last argument of the function call, you can just leave off the curly brackets:

~~~
irb> puts hash_keys(a: 1, b: 2)
a: 1
b: 2
~~~

That looks a whole lots like keyword arguments at that point. And yes, it's
easy to see that you could now just change the calling order without effects:

~~~
irb> puts hash_keys(b: 2, a: 1)
a: 1
b: 2
~~~

# Classes and Methods

A minimal class is defined with the `class` keyword, a name, and ends with `end`:

~~~ruby
class A

end
~~~

Despite this not doing much more then introducing `A` into your world. Let's see how to create a new `A` object `a`, how to ask it's `object_id`, how to get its string representation with `to_s` and finally how to ask an objects it's class:

~~~
irb> a = A.new
=> #<A:0x00007f913a9bb5e0>
irb> a.to_s
=> "#<A:0x00007f913a9bb5e0>"
irb> a.object_id
=> 70130865134320
irb> a.class
=> A
~~~

Not bad for a minute of work. You may be wondering where does all this functionality come from. Let's poke at the class hierarchy:

~~~
irb> a.class.ancestors
=> [A, Object, Kernel, BasicObject]
~~~

So `a` is an `A` which is an `Object` which is a `Kernel`, which is a
`BasicObject`. Forget about the latter 2. Do it. And note that of course
`Object` already has all that functionality, so we're merely tapping into
_inherited_ methods from `Object`:

~~~
irb> o = Object.new
=> #<Object:0x00007f913a82f898>
irb> o.to_s
=> "#<Object:0x00007f913a82f898>"
irb> o.object_id
=> 70130864323660
irb> o.class
=> Object
irb> o.class.ancestors
=> [Object, Kernel, BasicObject]
~~~

What about equality of such objects?

~~~
irb(main):013:0> a = A.new
=> #<A:0x00007f913d853380>
irb(main):014:0> b = A.new
=> #<A:0x00007f913d85a478>
irb(main):015:0> a == b
=> false
~~~

You may be used to constructors in other languages that get called by when
creating new objects using `new`. With an empty class we just use the
`initialize` of `Object`, but if you want to use your own (and you almost
always want to), here's how that would go:

~~~ruby
class A

  def initialize
    puts "you called new didn't you?"
  end

end
~~~

And then creating a new `A` would show:

~~~
irb> a = A.new
you called new didn't you?
=> #<A:0x00007fc4eb1b8bd8>
~~~

The class `A` is mostly useless. Usually classes carry some _state_ (cars have
doors and color, some cars have 4 doors, some 5, some cars are blue, some cars
are yellow). We capture that state using instance variables.

In Ruby, instance variables start with an `@`. So for example, let's give `A` some state:

~~~ruby
class A

  def initialize
    @a = 10
  end

  def print_your_state
    puts "my state is #{@a}"
  end

end
~~~

We did two things that are new:

- we're setting the value of `@a` in the `initialize`. Given what you know at this point, you'd expect that when you create a new `A` object that `@a = 10` line gets executed
- we've introduce an _instance_method_ called `print_your_state`. If you have an `A` object called `x` you can do `x.print_your_state`. This will execute the `puts` line for your object `x`.

~~~
irb> x = A.new
=> #<A:0x00007fc4ea1190c0 @a=10>
irb> x.print_your_state
my state is 10
~~~

Of course, every object would have `@a` equal to 10, whereas you'd like to
create objects with different states. You can accomplish this unexpectedly by
giving `initialize` arguments:

~~~
irb> x = A.new(10)
=> #<A:0x00007fc4eb1c1f80 @a=10>
irb> y = A.new(11)
=> #<A:0x00007fc4e9832c40 @a=11>
irb> x.print_your_state
my state is 10
irb(main):014:0> y.print_your_state
my state is 11
~~~

You can of course also give instance methods arguments:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def print_your_state_with_a_factor(x)
    result = @a * x
    puts "my state is #{result}"
  end
~~~

And then:

~~~
irb> x = A.new(10)
=> #<A:0x00007fc4eb145778 @a=10>
irb> x.print_your_state_with_a_factor(3)
my state is 30
~~~

This is interesting in that `result` is a _local_ variable to the instance
method `print_your_state_with_a_factor` and thus there's no `@` in sight when
`put`ing it.

Note that instance variables are _encapsulated_: you cannot get to its value from outside the class:

~~~
irb> x = A.new(3)
=> #<A:0x00007fc8cc180280 @a=3>
irb> x.a
Traceback (most recent call last):
        4: from /usr/bin/irb:23:in `<main>'
        3: from /usr/bin/irb:23:in `load'
        2: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        1: from (irb):4
NoMethodError (undefined method `a' for #<A:0x00007fc8cc180280 @a=3>)
~~~

That makes some sort of sense thinking of, for example, private instance variables in Java. You'd usually define a getter of some sorts:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def a
    @a
  end
end
~~~

And then:

~~~
irb> x = A.new(3)
=> #<A:0x00007f913a943c70 @a=3>
irb> x.a
=> 3
~~~

You could still not write to `@a` as that requires some sort of setter:

~~~
irb> x.a = 5
Traceback (most recent call last):
        4: from /usr/bin/irb:23:in `<main>'
        3: from /usr/bin/irb:23:in `load'
        2: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        1: from (irb):20
NoMethodError (undefined method `a=' for #<A:0x00007f913a943c70 @a=3>)
Did you mean?  a
~~~

We can write this ourselves:

~~~ruby
class A

  def initialize(a)
    @a = a
  end

  def a
    @a
  end

  def a=(a)
    @a = a
  end
end
~~~

and then:

~~~
irb> x = A.new(3)
=> #<A:0x00007fb09b838558 @a=3>
irb> x.a
=> 3
irb> x.a = 5
=> 5
irb> x.a
=> 5
~~~

I'll pause, so you can take this in.

~~~ruby
def a=(a)
  @a = a
end
~~~

That latter thing is an [assignment method](https://docs.ruby-lang.org/en/2.6.0/doc/syntax/assignment_rdoc.html#label-Assignment+Methods).
At this point the whole thing has become terribly obnoxious. Luckily, we have shorthand. We can accomplish what we had (a getter and a setter), by using `attr_accessor` as follows:

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end
end
~~~

Yes, you write `:a` there. 

~~~
irb> x = A.new(3)
=> #<A:0x00007fc5ab109988 @a=3>
irb> x.a
=> 3
irb> x.a = 6
=> 6
~~~

If you only want the getter, you can use `attr_reader`. If you only want a
setter (who are you?), you can use `attr_writer`.

As for some fun. What do you think will `x == y` be?

~~~
irb> x = A.new(3)
=> #<A:0x00007fa3d6194778 @a=3>
irb> y = A.new(3)
=> #<A:0x00007fa3d58ed458 @a=3>
irb> x == y
~~~

That's right. False. `x` and `y` are different objects and `==` is using
`Object` equality in this case. Sometimes it makes sense, to have `x` and `y`
be equal as they represent the same data namely an `A` with data `3`. If you
think, "yeah right", think of strings: `"I am right" == "I am right"` are the
same strings and we expect this to be `true`.

You can override `==` to accomplish that.

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end

  def ==(other)
    self.a == other.a
  end
end
~~~

And then:

~~~
irb> x = A.new(3)
=> #<A:0x00007fb47c1805a0 @a=3>
irb> y = A.new(3)
=> #<A:0x00007fb47c189268 @a=3>
irb> x == y
=> true
~~~

Couple of things worth pointing to:

- `==` can be just an instance method defined as any other method.  The reason is that `x == y`, is really just `x.==(y)` as if `==` is any other method name.
- I used `self` which is very similar to Java's `this` at least in _this_ [context](https://airbrake.io/blog/ruby/self-ruby-overview). Here it's the an instance of this object itself. So when we're doing `x == y`, and we thus execute `==` for the object `x`, then `self` would be `x`. Caveat emptor: `self` may mean other things. We will see in a bit how to use `self` to define _class methods_. 
- I did not actually have to use `self` here. There was no ambiguity if I'd have done `a == other.a`. The first `a` would have referred to the method `a` defined in `A` (by way of the `attr_accessor` and would have allowed me to check equality of the instance variable `@a` with `other.a` (aka the `@a` of the `other` object).

If you know `Java`, you must have met `static`. Used to indicate both variables
and methods in Java classes that belong to the type rather than the instance.
Aka, you can ask the class for the variables/methods. No need for an object. 

In Ruby _class variables_ are indicated with `@@` (recall that instance
variables are indicated with `@`). _Class methods_ are indicated by preceding
the name with `self`. The body is not yet cold and here we are: `self` in this
context, refers to the class (rather than the object). Let's see this in
practice:

~~~ruby
class A
  @@counter = 0

  def initialize
    @@counter += 1
  end

  def self.counter
    @@counter
  end

end
~~~

And then:

~~~
irb> x = A.new
=> #<A:0x00007fc82595ce60>
irb> A.counter
=> 1
irb> y = A.new
=> #<A:0x00007fc8259642a0>
irb> A.counter
=> 2
~~~

Note that we asked `A` for the `counter` (not `x`, nor `y`). In fact, doing
`x.counter` would lead to an `undefined method` error.

I avoided it for a while, but let's talk about inheritance. In the below I make `B` a subclass of `A` by indicating `B < A`.

~~~ruby
class A
  attr_accessor :a

  def initialize(a)
    @a = a
  end

  def double
    2 * @a
  end
end

class B < A
  def triple
    3 * @a
  end
end
~~~

And some poking at this:

~~~
irb(main):011:0> x = A.new(3)
=> #<A:0x00007fa19e02dd10 @a=3>
irb(main):012:0> x.double
=> 6
irb(main):013:0> y = B.new
Traceback (most recent call last):
        6: from /usr/bin/irb:23:in `<main>'
        5: from /usr/bin/irb:23:in `load'
        4: from /Library/Ruby/Gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `<top (required)>'
        3: from (irb):13
        2: from (irb):13:in `new'
        1: from /Users/sheymans/Workspaces/ruby_playground/src/ruby_playground.rb:7:in `initialize'
ArgumentError (wrong number of arguments (given 0, expected 1))
irb(main):014:0> y = B.new(5)
=> #<B:0x00007fa19f2184a8 @a=5>
irb(main):015:0> y.double
=> 10
irb(main):016:0> y.triple
=> 15
~~~

This works you expect it to work. Some quick notes:

- I did not give an `initialize` to `B` so we're forced to use the one of `A` which requires 1 argument `a` (which is what the _wrong number of arguments_ tells us)
- I could access the instance variable `@a` in `B`, given that was initialized in `A`. This could be surprising as in _where in the name does `@a` here comes from?_. I hope you got a decent IDE going for you.

# Modules

The general syntax of a module is easy. Use keyword `module`, give it a name and end with `end`:

~~~ruby
module HomeMade
  class A
    attr_accessor :a

    def initialize(a)
      @a = a
    end

    def double
      2 * @a
    end
  end

end
~~~

And then prepend `HomeMade::` to your class name `A` if you want an instance of this particular `A`:

~~~
irb> a = HomeMade::A.new(3)
=> #<HomeMade::A:0x00007fdf07147448 @a=3>
irb> a.double
=> 6
~~~

## As Namespaces

But why? One simple reason is that your neighbor also would like a class with
name `A`. That's just how he is. With modules, you can nicely isolate names:

~~~ruby
module HomeMade
  class A
    attr_accessor :a

    def initialize(a)
      @a = a
    end

    def double
      2 * @a
    end
  end
end

module NeighborMade
  class A
    # Same name A
  end
end
~~~

And now you can nicely differentiate which `A` you mean:

~~~
irb> a = HomeMade::A.new(3)
=> #<HomeMade::A:0x00007f95eb03f0b0 @a=3>
irb> b = NeighborMade::A.new
=> #<NeighborMade::A:0x00007f95ef0ef998>
~~~

In other words, modules can help you logically organize your classes/functions
within your application.

## As Mixins

Say you have 2 modules, 1 for logging and 1 for doing more long-term analytics (like sending Kafka events):

~~~ruby
module Logger
  def log_it(what)
    puts what
  end
end

module Analytics
  def send_event(event)
    puts event
  end
end
~~~

And you have a class `A` that would like to re-use the methods provided by both the `Logger` and `Analytics` modules:

~~~ruby
class A

  def do_something
    log_it("we're logging this")
    send_event('for long term analytics we send this')
  end
end
~~~

Trying this as is, will give you a `NoMethodError` for `log_it` and `send_event` if you try to do `a.do_something` for an object `a` of type `A`. `A` does not know about these things. You could be clever and say, well, let `A` inherit from `Logger`. Yes. And you'd want `A` to also inherit from `Analytics`. However, Ruby does not allow multiple inheritance. You can only inherit from 1 class (ignoring for a minute that `Logger` and `Analytics` are not actually classes, they are modules).

We can solve this by _mixing in_ the 2 modules in the class `A` by using `include`:

~~~ruby
class A
  include Logger
  include Analytics

  def do_something
    log_it("we're logging this")
    send_event('for long term analytics we send this')
  end
end
~~~

`include` makes all methods of the modules available as _instance_ methods in
your class. In the Java world, and maybe other worlds as well, you are reminded
immediately of the dreaded Utility class. Banish that memory.

# Testing

Say you have a class `A` that doubles, defined in a file `ruby_playground.rb`:

~~~ruby
class A
  def initialize(a)
    @a = a
  end

  def double
    @a * 2
  end
end
~~~

Let's unit test `double` by creating a new file `test_ruby_playground.rb` for it:

~~~ruby
require 'test/unit'
require './ruby_playground'

class RubyPlayGroundTest < Test::Unit::TestCase
  def test_double
    a = A.new(3)
    assert_equal 6, a.double
  end

end
~~~

This should look fairly familiar by now. Some new things:

- we `require` the `test/unit` Ruby gem which defines the class `Test::Unit::TestCase` for us.
- we `require` the file that has our own `A` with its `double`
- we create a new class `RubyPlayGroundTest` that inherits from that `Test::Unit::TestCase`
- we write a method that starts with `test_` and we use `assert_equal` to test whether `6` is indeed the result of `a.double`.

Running that test file should result in success with statistics:

~~~
$ ruby test_ruby_playground.rb
Loaded suite test_ruby_playground
Started
.
Finished in 0.000298 seconds.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1 tests, 1 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications
100% passed
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3355.70 tests/s, 3355.70 assertions/s
~~~

Try making the test fail and run the test again. Do it.

# Blocks


A quick reminder that we already saw blocks in action:

~~~
irb> a = [1, 2, 3]
=> [1, 2, 3]
irb> a.map { |el| el * 2 }
=> [2, 4, 6]
~~~

The piece `{ |el| el * 2 } is a _block_. You can distinguish the parameter part
`|el|` as well as the _body_ of that block `el * 2`. For multi-line blocks,
you'd use the `do...end` form, same potato though:

~~~ruby
a.map do |el|
 double = el * 2
 double + 1
end
~~~

Essentially you're giving one function `map` another function (the block) as an
argument. It's what they call higher-order functions in school children.

How do you define your own higher order function? Let's define a function that starts by printing "here we are now", and ends by printing "entertain us" to whatever function call we'd like. For example, say we want to print those 2 lines around a function call of `lost`:

~~~ruby
def lost
  puts 'a lost generation'
end
~~~

We could of course just do:

~~~ruby
puts 'here we are now'
lost
puts 'entertain us'
~~~

But if I'd want to do the same to another function than `lost` I'd have to repeat that. Let's define a higher-function that can prints those things for any other function:

~~~
def smells_like
  puts 'here we are now'
  yield
  puts 'entertain us'
end
~~~

You saw it: `yield`. That keyword tells the function `smells_like` _and now
execute the block that was given to your call my friend_. So if we do
`smells_like { lost }`, you see:

```
here we are now
a lost generation
entertain us
```

You could also just do `smells_like { puts 'a broken generation' }` and see:

```
here we are now
a broken generation
entertain us
```

What about blocks with parameters? For example, what if I want to be able to do
`smells_like('broken') { |x| puts "a #{x} generation" }`? `yield` can take
arguments, and yields arguments get shuttled into the block's arguments:

~~~ruby
def smells_like(something)
  puts 'here we are now'
  yield(something)
  puts 'entertain us'
end
~~~

And then:

~~~
irb> smells_like('lost') { |x| puts "a #{x} generation" }
here we are now
a lost generation
entertain us
irb> smells_like('broken') { |x| puts "a #{x} generation" }
here we are now
a broken generation
entertain us
~~~

Good times.

# Conclusion

We reached the end.


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

