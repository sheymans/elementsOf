<meta charset="utf-8">
                            **Elements of Ruby**
                            Stijn Heymans


# Introduction

I will attempt to introduce you to the elements of programming in
[Ruby](https://www.ruby-lang.org) from a beginner's mindset. I will assume you
can program in some other language (Java,
[Perl](http://www.stijnheymans.net/elements_of_perl.html), Python, whatever)
and so I'll not explain recursion, object-oriented programming, or other
concepts common to most programming languages.

I will mostly use 2 sources that were helpful to me and are worth digging into yourself:

- [Why's (Poignant) Guide to Ruby](https://poignant.guide/) by _why the lucky stiff_. That book is more art project than programming book, but it's also the one beginner's resource I found that gives an elemental overview of the language _with_ intuition of why things are the way they are in Ruby. If you already read that book, you can stop reading this article. You will not learn anything more than you already know.

- [Eloquent Ruby](https://www.goodreads.com/book/show/9364729-eloquent-ruby) by Russ Olsen. This takes things a step further and highlights the _Ruby_ way of doing common tasks, but also goes into meta-programming with Ruby that is easy to understand and gives you an inkling why Ruby might be different than some of the other languages out there.

Finally, and the source that stands a bit out, I will follow a structure that is
loosely inspired by the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) by Caleb
Doxsey. It's a great little book on Go, but most of all it's a great little
_short_ book on Go that manages to bring the basics across without decorum.
Something I aspire to in this article. Let's try.

# Getting Started

I assume you have some familiarity with basic command-line usage. Check whether
ruby is installed:

~~~shell
$ ruby --version
~~~

For me, it returns `ruby 2.6.3p62 (2019-04-16 revision 67580)
[universal.x86_64-darwin20]`). If you don't have it installed, you can get it
at [the ruby-lang website](https://www.ruby-lang.org/en/downloads/).

If you have ruby, you will have an interactive interpreter called
[irb](https://github.com/ruby/irb). On the command-line, type `irb`.

~~~
irb> puts 'Hello World!'
Hello World!
=> nil
~~~

Leave the interactive interpreter `irb` by typing `exit`. Now the same but
without `irb`. Open a file (make it end on `rb`, for example
`ruby_playground.rb`) and put the following line in it:

~~~ruby
puts 'Hello World!'
~~~

Close the file and at the command-line, have ruby execute it:

~~~
$ ruby ruby_playground.rb
Hello World!
~~~

Want to know more about `puts`? Get in the habit of looking that sort of info
up in the [official docs](https://docs.ruby-lang.org/en/) -
pick the right version of the docs corresponding to what you saw in your
initial `ruby --version`. I picked `2.6.0` as my ruby version is `2.6.3`.

This got us started.

# The Basic Classes

## Numbers

Unsuprisingly, integers are represented as we expect: `3`, `5, `-100`, ...
Suprisingly, everything in ruby is an object so you can ask the class of an
integer by doing `5.class`, which will return
[Integer](https://docs.ruby-lang.org/en/2.6.0/Integer.html). 

Since they're full-fledged objects there's more fun stuff one can do: 

~~~
irb> 123.digits
=> [3, 2, 1]
~~~

Yep, you can get an array of all digits that make up the integer. Fans of
coding interviews will like that, cause that's literally the only place you'll
ever need that.

You can do the usual math:

~~~
irb> 1 + 2
=> 3
irb> 2 * 3
=> 6
irb> 8 / 4
=> 2
~~~

Besides integers, you have our favorite inexact real numbers, represented by
[Float](https://docs.ruby-lang.org/en/2.6.0/Float.html) and in its literal form
things containing a decimal point:`1.0`, `9.9999`, ...

~~~
irb> 1.0.class
=> Float
~~~

First encounters are often unpleasant:

~~~
irb> 7 / 2
=> 3
~~~

Dividing 2 integers results in integer division. Force one to be a `Float`
using `to_f`:

~~~
irb> 7.to_f / 2
=> 3.5
~~~

## Strings

String are any characters surrounded by single quotes or double quotes:
`'Hello'` or `"Hello"`. The double-quoted variety are a bit special. I'll show
after talking about variables.

Use `+` to concatenate 2 strings without changing the original strings. Use
`<<` to concanate and destroy the string you're appending to:

~~~
irb> a = "hello"
=> "hello"
irb> b = "world"
=> "world"
irb> a + b
=> "helloworld"
irb> a
=> "hello"
irb> b
=> "world"
irb> a << b
=> "helloworld"
irb> a
=> "helloworld"
irb> b
=> "world"
~~~

You can use similar operations as for arrays to get to individual parts of the String:

~~~
irb> a = "hello"
=> "hello"
irb> a[0]
=> "h"
irb> a[-1]
=> "o"
~~~

You can get substrings by using inclusive (`..`) or exclusive (`...`) ranges:

~~~
irb> a = "hello"
=> "hello"
irb> a[0..2]
=> "hel"
irb> a[0...2]
=> "he"
~~~

## Symbols

Symbols consist of letters, digits, or underscores, and are preceded by a `:`.
For example, `:a`, `:a_2`, `:an_orange`. Well, why not just use Strings? [Great
question](https://stackoverflow.com/questions/255078/whats-the-difference-between-a-string-and-a-symbol-in-ruby).

Remember that I said everything is an object? So let's look a bit at how strings are different from objects:

~~~
irb> "bar".object_id
=> 70236502854760
irb> "bar".object_id
=> 70236502887440
irb> :foo.object_id
=> 1516508
irb> :foo.object_id
=> 1516508
~~~

You can learn several things from this:

- every object apparently has a method `object_id` that gives some sort of id.
- strings that look the same do not necessarily have the same `object_id`, which _probably_ has memory consequences
- symbols that look the same have the same `object_id`, which _probably_ has memory consequences

## Booleans

`true` and `false`. There.


# Variables

Like symbols they consist of letters, digits, or underscores. Unlike symbols,
they do not start with colons. You initialize them:

~~~
irb> x = 'hello'
=> "hello"
irb> x = 5
=> 5
irb> x = true
=> true
~~~

Note that you can assign and re-assign `x` to your heart's content and to
different types while you're at it. And you're at it.

Now is the time to start letting go of your _this is insane_ resistance.
Embrace it. When in Stockholm do like the Stockholmers do.

And as far as those single and double quotes go: 

~~~
irb> x = 2
=> 2
irb> "we were #{x}"
=> "we were 2"
irb> 'we were #{x}'
=> "we were \#{x}"
~~~

[String interpolation](https://en.wikipedia.org/wiki/String_interpolation) yes.

And sometimes variables are not so variable:

~~~
irb> X = 5
=> 5
irb> X = 6
(irb):5: warning: already initialized constant X
~~~

Capitalize your variable and it becomes _constant_: initialize it once and
never more.

A word on camels and snakes when naming variables or really anything. Use snake
case almost everywhere: `lowercase_words_separated_by_underscores`. Except
`ClassNames`, go for camel case there. Classes will be take their turn later.

# Control Structures

## Conditions and `if`

Here's the basic form:

~~~ruby
if condition
  do_something
end
~~~

So no parentheses (`(condition)`), no colon (`condition:`), no curly brackets
(`{ do_something }`). And `end` to end it.

The usual `else if` and `else` work like so:

~~~ruby
if condition
  do_something
elsif other_condition
  do_something_else
else
  final_thing_you_can_do
end
~~~

Conditions in `if` statements are expressions that evaluate to true or false.
So what all evaluates to true?

- all numbers (including `0`) are true
- all strings (including `''` -- the empty string) are true
- `nil` (yep, that's a null right there) is false
- the boolean literal `true` is true
- the boolean literal `false` is false
- the boolean expression `a && b` is true if `a` and `b` are true
- the boolean expression `a || b` is true if `a` or `b` are true
- the boolean expression `!a` is true if a is not true

Conditions can of course be the result of a function or method call which could
be true or false as well.

Your conditions will often compare things (if variable `a` is equal `"dog"`,
then do this). While you have `==`, `===`, `equal?`, and `eql?` in ruby, you
will mostly use:

- `==` for checking whether values are equal as far as the class designer of the objects you're comparing is concerned. 
- `equal?` for checking object equality.

In fact, `equal?` and `==` as defined in the
[`Object`](https://ruby-doc.org/core-3.0.2/Object.html#method-i-eql-3F) are
equal. Pun intended.

The intent is that `==` is overridden by class designers to something that
makes sense for your class, but that `equal?` always stands for object
equality. Take `String`:

~~~
irb> "a" == "a"
=> true
irb> "a".equal?("a")
=> false
~~~

So `"a"` is equal to `"a"` as values but as we saw before, they're not the same
objects. Looking at symbols:

~~~
irb> :a == :a
=> true
irb> :a.equal?(:a)
=> true
~~~

Back to our `if` for a bit. It's usual to instead of:

~~~ruby
if !condition
  do_something
end
~~~

to write:

~~~ruby
unless condition
  do_something
end
~~~

While this takes some getting used to, especially for my head, it's the ruby way.

Furthermore, if `do_something` is just one line, ruby often prefers the one-liner:

~~~ruby
do_something if condition
~~~

or

~~~ruby
do_something unless condition
~~~

Especially when returning early from functions, this makes code readable:

~~~ruby
return if invalid_parameters
~~~

## Looping

This is an area where ruby is opinionated. Say there's no collection like an
Array or Hash in sight, and in some other language (say `go`), we'd write:

~~~go
n := 5
for i := 0; i < n; i++ {
  fmt.Println(i)
}
~~~

This would print:

~~~
0
1
2
3
4
~~~

There's a variety of ways to write this in valid ruby, but the construct as
above does not exist.

Closest in spirit to the above one is to probably use a while:

~~~ruby
n = 5
i = 0
while i < n
  puts i
  i += 1
end
~~~

which is arguably slightly more verbose than the corresponding `for` loop in `go`.

A more ruby way is to probably use [`times`](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times):

~~~ruby
n.times { |i| puts i }
~~~

Now this is arguably quite elegant. But what's going on?

Let's analyze it's parts:

- `n`. An `Integer`, so an an object that has methods
- `times`. A [method](https://docs.ruby-lang.org/en/2.6.0/Integer.html#method-i-times) that is called on the object and _iterates_ the following block `{ |i| puts i}` from `0` to `n - 1`, passing in those values to `i` with each iteration. Wow. More on blocks later. For those familiar, the block is essentially an anonymous function or lambda with parameter `i` (or arrow function for the Javascript knowledgeables). 
- `{ |i| puts i }`. We spoiled it, but this is a `block` that prints `i` with `i` ranging over values `0` to `n - 1`. This _feeding_ is accomplished by `times`. We'll see later how we can write functions such as `times` ourselves in the section on Blocks. For now, you can see `times` as an higher-order function that takes another function as an argument and executes. 

We'll do more looping in the Arrays and Hashes section, as most of the time
your looping will be in the context of some collection and also in that case
ruby has opinions.

# Arrays and Hashes

## Arrays

An array is an [ordered integer-indexed collection](https://docs.ruby-lang.org/en/2.6.0/Array.html) of objects. Let's initialize one:

~~~
irb> a = ["x", 1, :y]
=> ["x", 1, :y]
~~~

Arrays are in other words not restricted to 1 type of objects. You can shuffle
in there what'd you like. "Oh yeah??!!". Yes:

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
~~~

The usual suspects with a special mention for `-1` (the last of the elements):

~~~
irb> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb> a.length
=> 3
irb> a[1]
=> [1, 2]
irb> a[-1]
=> :y
~~~

You can add elements to the back of an array using `<<` or `push`. Both are destructive operations:

~~~
irb> a << :b
=> ["x", [1, 2], :y, :b]
irb> a.push(:c)
=> ["x", [1, 2], :y, :b, :c]
irb> a
=> ["x", [1, 2], :y, :b, :c]
~~~

You can remove that last element again using `pop`:

~~~
irb> l = a.pop
=> :c
irb> a
=> ["x", [1, 2], :y, :b]
~~~

What about adding and removing to the _front_ of an array? Use `unshift` and `shift`. As far as unsavory mnemonics go, remove the `f` to remember which does what.

~~~
irb> a
=> ["x", [1, 2], :y, :b]
irb> f = a.shift
=> "x"
irb> a
=> [[1, 2], :y, :b]
irb> a.unshift("x_new")
=> ["x_new", [1, 2], :y, :b]
~~~

But `pop/push` must be more efficient than `shift/unshift` right? Seems [it
hardly
matters](https://stackoverflow.com/questions/8353026/what-is-the-run-time-of-shift-unshift-in-a-ruby-array).

What if you have a second array `b = [:b1, :b2]` that you want to append (i.e., add each element) to `a`? Just using `push` will not do what you want:

~~~
irb(main):019:0> a = ["x", [1, 2], :y]
=> ["x", [1, 2], :y]
irb(main):020:0> b = [:b1, :b2]
=> [:b1, :b2]
irb(main):021:0> a.push(b)
=> ["x", [1, 2], :y, [:b1, :b2]]
~~~

However, using the _splat_ operator `*` will:

~~~
irb> b = [:b1, :b2]
=> [:b1, :b2]
irb> a.push(*b)
=> ["x", [1, 2], :y, :b1, :b2]
~~~

`*b` for an array `b` in the context of a function call (`push` here) will send
each element of the array as an individual argument to the function. In other
words, `a.push(*b)` is the same as `a.push(:b1, :b2)`.

So far we initialized arrays using their literal form (such as `a = [1, 2]`).
We can also initialize them using the `new` method from the
[Array](https://docs.ruby-lang.org/en/2.6.0/Array.html) class:

~~~
irb> a = Array.new
=> []
irb> a << 1
=> [1]
~~~

## Hashes

[Hashes](https://docs.ruby-lang.org/en/2.6.0/Hash.html) are structures to store
key-value pairs with unique keys (also called dictionaries, associate arrays,
`HashMap`, maps in other languages). You can use any object type as a key.

Define a hash with some personal information and do some basics like getting a value for an existing key, a non-existing key, changing a value for an existing key, adding a value for a non-existing key, and removing a key/value pair:

~~~
irb> a = { "first" => "John", "last" => "Doe" }
=> {"first"=>"John", "last"=>"Doe"}
irb> a["first"]
=> "John"
irb> a["nothere"]
=> nil
irb> a["first"] = "Jane"
=> "Jane"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
irb> a["first"]
=> "Jane"
irb> a["nothere"] = "now it is here"
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe", "nothere"=>"now it is here"}
irb> a.delete("nothere")
=> "now it is here"
irb> a
=> {"first"=>"Jane", "last"=>"Doe"}
~~~

What type of objects can all be values? Any object.

What type of objects can all be keys, surely only Strings right? Any object.

Let's start with showing symbols as keys as there's some syntactic sugar for those.

~~~
irb> a = { :first => "John", :last => "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a[:first]
=> "John"
~~~

Nothing interesting happened. You used symbols `:first` and `:last` as keys. If
you do that, you can get all JSON-y instead:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
~~~

Same hot sauce though.

I confidently said you can use any object as a hash key. You can both in order
to have certain expectations met (like: if the objects are the "same", only 1
hash key that is that object should be in your hash). This relies on properly
overriding `hash` and `eql?` (the latter being what
[Hash](https://docs.ruby-lang.org/en/2.6.0/Hash.html) uses for testing equality
of keys. [Two objects will then refer to the same key when their `hash` value
is identical and the 2 objects `eql?` each
other](https://docs.ruby-lang.org/en/2.6.0/Hash.html#class-Hash-label-Hash+Keys).
Is this still elemental? Probably not. Moving on.

## Looping through Arrays and Hashes

You will spend half of your life looping through arrays and hashes. Say you have an array:

~~~
a = [100, 200, 300]
~~~

Let's print each element.

~~~
a.each { |el| puts el }
~~~

No `for` in sight. Use `each` when you can. `each` iterates through the
elements of the array and binds each to _el_ in the block `{ |el| puts el }`,
and then executes the `puts el`. Often you'll do more than a one-liner, and
you'll use the `do` variety:

~~~ruby
a.each do |el|
  puts el
  puts el
end
~~~

Same thing, but you use `do...end`

Sometimes you will want the index as well. So similar to the trickery we saw before you could do:

~~~ruby
a.length.times { |i| puts a[i] }
~~~

That works obviously as computers do not have opinions. More idiomatic as far
as I could tell is to use `each_with_index`. Let's also throw that string
interpolation in the mix:

~~~
irb> a.each_with_index { |el, i| puts "#{i}: #{el}" }
0: 100
1: 200
2: 300
~~~

Yeah, get those [Anki flashcards](https://apps.ankiweb.net/) out to memorize
the order of that `|el, i|`. Alternatively, in ruby syntax, it often works to
think "how would I say this out loud?": in the array `a`, for _each_ `el` at
index `i`, do something. If you naturally go to _for each index `i` which has
element `el`_ you're on your own in this mess, my friend.

You can loop over a hash with `each` as well:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> John
last -> Doe
~~~

This should not be suprising. In case you want to see just the keys of a hash, you have

~~~
irb> a.keys
=> [:first, :last]
~~~

And similarly for the values in a hash:

~~~
irb> a.values
=> ["John", "Doe"]
~~~

In contrast to usual hashes (e.g., in Java), you _can_ assume an order on key-value pairs in ruby. They will be in the order they were inserted:

~~~
irb> a = {}
=> {}
irb> a["first"] = 1
=> 1
irb> a["second"] = 2
=> 2
irb> a.each { |key, value|  puts "#{key} -> #{value}" }
first -> 1
second -> 2
~~~

Sometimes you can benefit from going one abstraction higher than pure looping, and use a [`map`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map):

~~~
irb> a = [1, 2, 3]
=> [1, 2, 3]
irb> b = a.map { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [1, 2, 3]
~~~

If you do not want a new array, you can use the [destructive variant
`map!`](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-map-21):

~~~
irb> a.map! { |x| x * 2 }
=> [2, 4, 6]
irb> a
=> [2, 4, 6]
~~~

The convention in Ruby is to indeed append `!` to function names if those
functions are supposed to be destructive.

We can also map hashes. For example, collect all keys of a map, but uppercased:

~~~
irb> a = { first: "John", last: "Doe" }
=> {:first=>"John", :last=>"Doe"}
irb> a.map { |key, value| key.upcase }
=> [:FIRST, :LAST]
~~~

Instead of that 1 value in the block arguments, we have 2: `|key, value|` as we're dealing with a Hash. We map that key-value pair to `key.upcase`, and `map` collects those in an Array. What if you want to map a Hash to a Hash, but just keeping the keys but uppercasing the values:

~~~
irb> a.map { |key, value| [key, value.upcase] }.to_h
=> {:first=>"JOHN", :last=>"DOE"}
~~~

The tricky part is that the `map` gives us an array of `[key, value.upcase]`
arrays. So we use `to_h` to convert that very specific array to a hash.
Generally:

~~~
irb> [[1, 2], [3, 4]].to_h
=> {1=>2, 3=>4}
~~~

We're verging to the non-elemental, so moving on.

# Functions

Your first unit of abstraction are functions (or _methods_, when appearing in classes, same potato). Functions take the following shape:

~~~ruby
def function_name(arg1, arg2,...)
  # do stuff
end
~~~

Functions start with `def` and end with `end`. A function that doubles an array `a`:

~~~ruby
def double_all(a)
  a.map { |x| x * 2 }
end
~~~

"Oh no," you may say. "They forgot to type the arguments, what a nightmare to
read code like that,". Yes, but embrace it. Essentially, your `a` can be
anything as long as it understands `map`. Yes, yes, interfaces and all. 

Calling functions is as you would expect:

~~~
irb> a = [1, 2, 3]
irb> puts double_all(a)
2
4
6
~~~


You have options if you do not want to embrace it. Check out
[sorbet](https://sorbet.org/) which allows you to annotate your functions with
type information. For example, the above would be intended for:

~~~ruby
sig { params(a: T::Array[Integer].returns(T::Array[Integer]) }
def double_all(a)
  a.map { |x| x * 2 }
end
~~~


TODO: mention [hashes as arguments](https://docs.ruby-lang.org/en/2.6.0/Hash.html)

# Classes and Methods

# Modules

TODO:

- class `extend` a module

# Testing

# Blocks

Abandoning the structure of [Introducing
Go](https://www.goodreads.com/book/show/27015358-introducing-go) to go a bit deeper into _blocks_.


# Conclusion


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

