

<meta charset="utf-8">
                            **Elements of Perl**
                            Stijn Heymans
                            12 October 2019

# Introduction

This article highlights language elements from `perl 5.x`, focusing on 1 way to
do something, rather than explaining all the ways something can be done in
perl.  To prepare for this article, I studied these 3 books, which when read in
order will provide you with a solid perl basis:

- [Learning Perl: Making Easy Things Easy and Hard Things Possible](https://www.goodreads.com/book/show/30413201-learning-perl) by Randal L. Schwartz, Brian D. Foy, Tom Phoenix,
- [Intermediate Perl](https://www.goodreads.com/book/show/209276.Intermediate_Perl) by Randal L. Schwartz, Brian D. Foy, Tom Phoenix,
- [Perl Best Practices: Standards and Styles for Developing Maintainable Code](https://www.goodreads.com/book/show/86379.Perl_Best_Practices) by Damian Conway.

Compared to those books, this article is incomplete and opinionated. For
example, there is a section on constants, purely because `Java` programmers
will wonder _how do I do constants in perl?_ My hope is that the article
represents some core of how to use `perl` most effectively, leaving what
_effective_ means purposefully out of sight.
In the best case, I managed to capture some _elements of_ perl, in the worst
case, it's _my_ elements of `perl`.

I have at the time of writing about 8 months of `perl` reading/writing
experience under my belt from working at
[ZipRecruiter](http://ziprecruiter.com). I'm of course still a beginner with
`perl` but I bring some experience from other languages (Java, Python, Clojure,
Lisp, ...).

Enjoy reading and if you have questions, something I can clarify, or errors
you found, please let me know at stijn.heymans@gmail.com

--Stijn Heymans, October 2019.

# Scalars

## Strings

### Basics

_Scalars_ or _scalar values_ are the smallest unit of data in perl. Numbers and
strings are scalars.

We store scalars in _scalar variables_, for example, let's look at how to store
and manipulate strings in this section:

~~~perl
my $var = 'I am a string';
~~~

!!! note
   _statements_ in perl end with `;` as they do in Java or C++.

The `my` keyword _declares_ the variable (similar to a `let` in Javascript),
and `$var` consists of the symbol `$` and the name `var`. The use of symbols
like `$` is something to get used to when switching from Python/Javascript to
perl. The symbol `$` hints at how the variable is used or accessed. In this
case, it declares and initializes a string, which is a scalar, and thus the
symbol `$` emphasizes that.

You'll later see a symbol `@` for array usage and `%` for hash usage (a `hash`
is Python's `dict` or generally a key-value structure such as a `Map` in Java).

Back to strings. A common operation is concatenating 2 strings:

~~~perl
my $concat = $var . ' and me too.';
~~~

If you'd like to change `$var` by concatenating something to it, instead of
`$var = $var . ' and me too.'` you can do:

~~~perl
$var .= ' and me too.';
~~~

Note that we used single quotes for strings. What about double quotes?. You can
use double quotes as well. Good practice is to use them only when you want to
_interpolate_ variables appearing in such strings. For example:

~~~perl
my $name = 'stijn';
my $hello = "my name is $name";
~~~

Interpolation makes sure that `$name` in that `$hello` string is always
_expanded_ to its value. In this case, the string will be `my name is stijn`.
Interpolation will usually lead to cleaner code than concatenation. Compare the above to:

~~~perl
my $name = 'stijn';
my $hello_conc = 'my name is ' . $name; 
~~~

Why is it good practice to only use them when you actually want to interpolate
variables? Imagine I have 

~~~perl
my $money = "my password is !$guest";
~~~

In this case `perl` will try to expand `$guest` which does not exist and will
result in warning and an unexpected result in `$money`.

You actually meant:

~~~perl
my $money = 'my password is !$guest';
~~~

You can extract individual characters out of a string similar to you'd do it in
other languages:

~~~perl
my $string = 'what';
my $first = $string[0];
~~~

You can get the last character of the string using the index `-1`, something you
might know from `Python`:

~~~perl
my $last = $string[-1];
~~~

And yes, you'd get the next-to-last element, by accessing it using `-2`.


### Built-in Functions

#### [`print`](https://perldoc.perl.org/functions/print.html)

Printing to `STDOUT` will be mostly useful for debugging the odd statement here and there:

~~~perl
print "This is a printed string\n";
~~~

!!!
   There's an explicit `\n` in that statement; you might be used to a `println`
   from other languages that puts that `\n` there for you. But `perl` is not
   putting it there for you.


#### [`substr`](https://perldoc.perl.org/functions/substr.html)

Extract a substring out of a string. For example, to get a `cat` out of `concatenate`, do:

~~~perl
my $cat = substr('concatenate', 3, 3);
~~~

The first `3` is the offset from where to start the substring, the second `3`
is the length of the substring you want (_cat_ has 3 letters). You'll see this
pattern occur frequently, an _offset_ followed by a _length_ in the arguments
of a function.

If you leave off the length, you'll just take the substring until the end of
the string, for example to get `catenate`:

~~~perl
my $nonsense_substring = substr('concatenate', 3);
~~~

#### [`split`](https://perldoc.perl.org/functions/split.html)

`split` splits a string into parts based on a regular expression
`/REGEXP/`. However, I will just mention the form you'll often spot in the
wild:

~~~perl
split //, 'yeah';
~~~

This will split the string `yeah` into its individual characters because the
pattern `//` matches _everything_ and returns a list of individual characters.
We will introduce lists/arrays later, and we'll also talk in a bit more detail
about regular expressions.


!!! 
   Note the `split //, 'yeah'` without parenthesis. Based on
   how I wrote `substr` you expected to see `split(//,'yeah')` and you'd been
   right as well! `perl` is playing loose with parentheses, so for
   built-in functions you'll often see parentheses dropped. For functions you
   write yourself, I suggest to keep parentheses when invoking them. Life is
   complicated enough as it is.


## Numbers

### Basics

Let's dive into numbers.

~~~perl
my $numero = 42;
~~~

Easy enough. We can add numbers:

~~~perl
my $sum = $numero + 42;
~~~

which is of course the same as if we would have done:

~~~perl
my $doubling = 2 * $numero;
~~~

Similar like in other languages, there is a short hand for `$numero = $numero + 42`:

~~~perl
$numero += 42;
~~~

and for the other operations _la mÃªme chose_.

### Built-in Functions

This is where you'd see an enlightening _this is how to take the square
root_ using the built-in `sqrt`. You would.

You can `print` numbers and a good conversion (the `%d` in the below template string) is...`%d`:

~~~perl
print "The meaning of life is %d", 42;
~~~

## `undef`

I talked about scalars like strings and numbers. But what about `null`? `null`
is a _thing_! Does `perl` have a `null`? Yes: `undef`. And where you'll see
in other languages a lot of null-checks, in `perl`, you'll see a lot of:

~~~perl
if (defined $x) {
  # stuff
}
~~~

which checks whether `$x` is defined (so is `$x` `undef` or not).

What's with the 

~~~perl
# stuff
~~~

A `#` marks comments. Anything following it is ignored by the `perl` compiler.

# Array Variables

## Basics

People distinguish between an _array_ and a _list_. This is how you create an
array with elements `I`, `do`, `not`, `care`:

~~~perl
my @array = ('I', 'do', 'not', 'care');
~~~

Note the `@` symbol prefixing the variable name. In contrast to
other languages like Python or Javascript, `perl` gives you a hint on what
kind of variable something is. We already saw _scalar_ variables in which you
can store the smallest unit of _things_ (for example, numbers or strings). The `@` signifies this is an _array_
variable and stores a _list of things_. And the wording of _things_ is
intentional. Array variables store lists of _things_. So if a list contains the
variable, that variable will be a _scalar variable_.

I have find this probably the most confusing _thing_ (so I'd store my confusion
in a scalar).

Let's complicate this slightly more. Try getting the first element of the array `@array`:

~~~perl
my $first_element = $array[0];
~~~

The `[0]` part should look familiar, but note that it is `$array` when you use
`@array` to _access_ the scalar value at the first position (index `0`). Or
differently put, while `@array` is an array, `$array[0]` is a scalar which
could be a reminder for why we use `$` in that case rather than `@`.

The last element is usually easily retrieved using the `-1` index (similar to
for accessing characters in a string we saw before):

~~~perl
my $last_element = $array[-1];
~~~

We can change an element similarly as retrieving. Change the first element of `@array`:

~~~perl
$array[0] = 'You';
~~~

I can copy an existing array `@array` to a new array `@copy`:

~~~perl
my @copy = @array;
~~~

Note that here I again use `@` for both: I'm creating an array `@copy` and
copying the array `@array` (I am not referring to the individual elements in
`@array`: the array is used in a _list_ context).

Note that this is indeed a copy: changing elements in `@copy` will _not_ change
elements in `@array`.

## Built-in Functions

### Adding and Removing from Back of an Array


You can remove elements from the back/end of an array, using [`pop`](https://perldoc.perl.org/functions/pop.html):

~~~perl
my @array = (4, 5);
my $last = pop @array;
~~~

Note that we did not write `pop(@array)` as `pop` is a built-in. We leave
parentheses off of built-ins per convention. What will `$last` store? It will
store the last element of `@array`: `5`. What will `@array` store after the
`pop`ping? An array with the last element removed: `(4)`.

You can add it back by adding it to the end of array using [`push`](https://perldoc.perl.org/functions/pop.html):

~~~perl
push @array, 5;
~~~

Then, `@array` will be `(4, 5)` again. You can also use `push` to append a list:

~~~perl
push @array, (4, 5);
~~~

### Adding and Removing from Front of an Array

Sometimes you'd want to add something to the front of an array, and we use the
very memorable [`unshift`](https://perldoc.perl.org/functions/unshift.html)
for that:

~~~perl
unshift @array, 4;
~~~

This adds `4` to the front of `@array`. Note that you can also pre-pend lists like that:

~~~perl
unshift @array, (4, 5)
~~~

This would turn an `@array` that is `(6, 7)` into `(4, 5, 6, 7)`. Note that the order is
preserved (so it does not loop through `(4, 5)` and adds the elements one by
one)

Similar to how `pop` removes from the back of the list, we have a function to remove something from the start of the list:

~~~perl
my $first = shift @array;
~~~

`@array` will be modified after this: the first element is removed and in this
case we stored it in `$first`. You can imagine
[`shift`](https://perldoc.perl.org/functions/shift.html) as shifting the array
to the _left_ and thus dropping the first element.

### Length of an Array with a detour to contexts

The length of an array is a funny thing. The notion of _context_ (briefly
mentioned before) is important in `perl`. For example, assigning an array to a
scalar variable, will cause the _length_ of that array to be assigned to the
scalar. Indeed, you cannot store an array into a scalar, so what do you store?
Well, a reasonable thing to store is the length of that array. So for this:

~~~perl
my @array = ('hey', 'you');
my $scalar_something = @array;
~~~

we have that `$scalar_something` now contains `2`: the length of `@array`. 

This also works the other way: what if you want to store a scalar into a list?
For example:

~~~perl
my $scalar = 'a';
my @array = $scalar;
~~~

You're now trying to store a scalar variable `$scalar` into an array variable,
or in other words, into a _list context_. `perl` will try to make a list out of
the scalar, and the natural way to do so is by treating your scalar as a list
with 1 element in it (the scalar). So `@array` will effectively be the list
`('a')`.


### [`reverse`](https://perldoc.perl.org/functions/reverse.html)

We can reverse arrays as follows:

~~~perl
my @array = (1, 2);
my @rev = reverse @array;
~~~

`@rev` will be `(2, 1)` and `@array` will have stayed the same (so `reverse` is
non-destructive on its argument). Contrast that with `pop`/`push` and
`shift/unshift` all of which are destructive on the lists they operate on.

# Hash Variables

## Basics

Most programming languages have some variation of a key/value data structure (a
`Map in Java`, a `dict` in Python).  In `perl` such a key/value store is called
a _hash_. A hash _literal_ can be initialized as follows:

~~~perl
my %some_hash = ('name', 'john', 'age', 39);
~~~

Note: 

1. we used a new symbol `%` to indicate that `some_hash` is a variable used to store a hash. 
2. there seems to be no syntactical distinction between keys and values. We'd expect `'name'` and `'age'` to be keys, and `'john'` and `39` to be values. Instead, this has the same syntax as a literal list. In fact, it _is_ just a list. Let's get back to our _contexts_. We already saw a _list context_ and a _scalar context_. The `%` on the left-hand side of the assignment, indicates a _hash context_ and whereas the right-hand side is indeed a list, we are trying to assign the list to a hash such that effectively we indeed store a hash (i.e, something we can access based on keys `'name'` and `'age'` as we will see in a bit).
3. The keys `'name'` and `'age'` are strings while the values are strings or numbers (`39`). Indeed, the keys of a hash are always strings. The values are less strict and can be any _scalar_. As such we cannot nest hashes by embedding another hash as a value within a hash. At least not without a final concept called _references_ which we'll introduce later. For now, remember that values of a hash are always scalars.

As the list syntax for hashes is obviously confusing, `perl` has a trick (of
course it has). We can replace certain commas by so-called `fat commas`: `=>`.
A fat comma `=>` is absolutely the same as a comma for the perl parser, but for
us mere humans, it makes things a bit more palatable:

~~~perl
my %some_hash = ('name' => 'john', 'age' => 39);
~~~

When using the fat arrow notation, you can also leave of the quotes on the keys:

~~~perl
my %some_hash = (name => 'john', age => 39);
~~~

We can access values of a hash, using curly braces (`{` `}`):

~~~perl
my $name = $some_hash{name};
my $age = $some_hash{age};
~~~

Note that I did not write `'name'` nor `'age'`: indeed once `%some_hash` is
established as a hash, you can access values by using the keys without quotes
whether you initialized with quoted keys or not. However, you _could_ have written:

~~~perl
my $name = $some_hash{'name'};
my $age = $some_hash{'age'};
~~~

Same difference. We also used the scalar `$` symbol instead of the hash symbol
`%` when _accessing_ the hash. In effect, we're accessing a scalar so we use
`$`. Or differently, `$some_hash{name}` _is_ a scalar (always, by the rule
that values in hashes have to be scalars) rather than a _hash_, so it makes
sense to refer to it with `$`.

Changing the value for a key is can be done without surprises:

~~~perl
$some_hash{name} = 'bill';
$some_hash{age} = 40;
~~~

## Built-in Functions

### `values`/`keys`

As is usual with map-like structures in programming languages, you can get the
keys `age` and `name` from the hash:

~~~perl
my @keys = keys %some_hash;
~~~

Indeed, `@keys` will be the array `('age', 'name')`. Similarly, you can get the
values `39` and `john` from the hash:

~~~perl
my @values = values %some_hash;
~~~

Indeed `@values` will be the array `(39, 'john')`. Note that even though we
defined `%some_hash` using the literal `('name', 'john', 'age', '39')` which
hints at some _ordering_, neither `values` nor `keys` need to satisfy that
original order. 

# References

_References_ or the concept that makes nested structures possible. Recall that
arrays can store lists of scalars and hashes are key-value maps where the key
needs to be a string and the value needs to be a scalar.

At first sight this restricts us to rather flat data structures, for example, I
could not directly store a list of hashes. Or a hash that is an index of names
(the key) to person's addresses (the value, consisting of street, zip code)).

No-one wants to be restricted, the least of all to flat data structures. Enter: the _reference_. To
some degree the reference is a bit like C/C++ style pointers. It is 
a _scalar_ that _points_ to other _things_. Those other other things could
be other lists, hashes, or other scalars, and....other references.

For example, say we have a reference `$a_ref` (note that references are
scalars, so here we go with the `$` again) that points to an array `(1, 2, 3)`:

***********************************
*                                 *
*   .--------.       .----------. *    
*   | $a_ref +----->| (1, 2, 3)  |*
*   '--------'       '----------' *
***********************************

This now means that we can indeed have a hash with values that are pointing to arrays:

~~~perl
my %array_value_hash = (john => $a_ref);
~~~

I kept a crucial piece to myself though. How did I create that `$a_ref`
reference to the array `(1, 2, 3)`? Recall that we would create an array
variable as follows:

~~~perl
my @array = (1, 2, 3);
~~~

I can now take a reference to `@array` using the backslash \:

~~~perl
my $a_ref = \@array;
~~~

There's a shorthand for taking a reference to an array _literal_ though:

~~~perl
my $a_ref = [1, 2, 3];
~~~

So use square brackets `[ ]` instead of `( )`. Effectively, this:

~~~perl
my @array = (1, 2, 3);
my $a_ref = \@array;
~~~

is the same as:

~~~perl
my $a_ref = [1, 2, 3];
~~~

How could I now get values out of that array, given the reference `$a_ref`
rather than using the `@array`. Well, recall that you could get the first
element (or change the first element) of `@array`, doing `$array[0]`. We can
get to the underlying array based on the `$a_ref` reference, by
_de-referencing_ it (pointers anyone?) using curly brackets `{$a_ref}`. Getting
the first element based on `$a_ref` can then be done by:

~~~perl
my $first = ${$a_ref}[0];
~~~

A similar dereferencing rule holds in situations where you'd normally deal with the array itself like when copying:

~~~perl
my @copy = @array;
~~~

To make a copy based on the `$a_ref`, you could do:

~~~perl
my @copy = @{$a_ref};
~~~

You can see that we just switched out the `array` part in `@array` by the
dereferenced reference: `{$a_ref}`.

We can of course copy array references and one would expect that if I change a value in the copied array reference I'd be changing the original:

~~~perl
my $copy_ref = $a_ref;
~~~

***********************************
*                                 *
*   .--------.       .----------. *    
*   | $a_ref +----->| (1, 2, 3)  |*
*   '--------'       '----------' *
*                         ^       *
*   .-----------.         |       * 
*   | $copy_ref +--------'        *
*   '-----------'                 *
*                                 *
***********************************

If we then change `$copy_ref` we'd expect to change the underlying array:

~~~perl
${$copy_ref}[0] = 500;
~~~

Indeed both `${$a_ref}[0]` and `${$copy_ref}[0]` will now be equal to `500`:

************************************
*                                  *
*   .--------.       .-----------. *    
*   | $a_ref +----->| (500, 2, 3) |*
*   '--------'       '-----------' *
*                           ^      *
*   .-----------.           |      * 
*   | $copy_ref +----------'       *
*   '-----------'                  *
*                                  *
************************************

To always type `${$a_ref}` is not very succinct. We can do better. These are all the same:

~~~perl
${$a_ref}[0]; # what we saw before
$$a_ref[0];   # 2 consecutive `$` so leave of braces (we'll not use this notation)
$a_ref->[0];  # use an arrow notation to indicate that `$a_ref` is actually a reference
~~~

That's that for array references. What about hash references? Similarly to
array references you can take a reference by using a backslash \:

~~~perl
my %hash = (age => 9);
my $hash_ref = \%hash;
~~~

Note again that `$hash_ref` is a scalar and thus indicated with `$`. We can
thus use this hash reference as values in other hashes or as members of an
array.

As with arrays there is a shorthand for creating such hash references:

~~~perl
my $hash_ref = { age => 9 };
~~~

Namely, use `{ }` instead of `( )`. You will see that frequently and it will
comfort you as it is similar notation to JSON or Python `dict`s.

Accessing values from hash references is similar. Recall that if you'd want the value `9` of the above `%hash`, you'd do:

~~~perl
$hash{age};
~~~

We have a similar _trick_ when you want to get that value via the `$hash_ref`
where we replace the name `hash` by dereferencing the `{$hash_ref}` that refers
to it:

~~~perl
${$hash_ref}{age};
~~~

Also this form has an easier to read form using an `->` notation:

~~~perl
$hash_ref->{age};
~~~

which we will mostly use going forward.


# Conditions

We all want control, _if_ we only could have it:

~~~perl
if ( $age == 18 ) {
  # stuff
}
~~~

The syntax for `if` is as you're used to from C, Java, JavaScript, ....

Note the equality test using `==`. Inequality would be tested with `!=`:

~~~perl
if ( $age != 18 ) {
  # stuff
}
~~~

or by using the negation operator `!` directly:

~~~perl
if ( !($age == 18) ) {
  # stuff
}
~~~

Note the extra parenthesis. This is needed in this case, indeed `!$age == 18`
would lead to `!$age` being interpreted first. Since `$age` is a number but `!`
forces a boolean context, and given that, any number other than `0` is
considered truth, we have that `!$age` is false if `$age` is not 0. And false
is never equal to `18` so `!$age == 18` would always be false. Neither is true
by the way, so even if `$age` is 0, we'd have that `!$age` is true. It's
confusing, let's just say that.

Other useful operators are `&&` for logical _and_, `||` for logical _or_.

We have the usual `else`:

~~~perl
if ( $age == 18 ) {
  # stuff
}
else {
  # other stuff
}
~~~

You can do cases using `elsif`:

~~~perl
if ( $age == 18 ) {
  # stuff
}
elsif ( $age > 18) {
  # other stuff
}
else {
  # more stuff
}
~~~

Note that it's _not_ `elseif` nor `else if`. It's `elsif`.

`perl` also has the `unless` keyword for the "`if` not" situation. Do not use
`unless` unless you feel like getting confused. Are you confused? I am.

Conditions are useful outside of `if`s to filter an array keeping only the
items that satisfy a condition. `perl` has `grep` for that (yes, named
after that [`grep`](http://linuxcommand.org/lc3_man_pages/grep1.html). 

Say we want to create an array containing only negative numbers:

~~~perl
my @all_numbers = (9, -7, -6, 5, 4);
my @negatives = grep { $_ < 0 } @all_numbers;
~~~

I was able to avoid `$_` for a long time, but no more. `$_` is a scalar
variable (given away by the `$`). And the `_` can be memorized as something that points to _whatever makes
sense at this point in the code_. When used in a `grep`,`$_`, will contain, in
sequence, every number from `@all_numbers`. `grep` will apply the condition `$_
< 0` and will keep only those numbers that satisfy that condition (and store it
in `@negatives`).

Thus, `@negatives` will contain `(-7, -6)`.

How could figure out whether there is _any_ negative number (i.e., is there at
least 1 negative number?) in a list `@all_numbers`. You could then do this:

~~~perl
my @all_numbers = (9, -7, -6, 5, 4);
my @negatives = grep { $_ < 0 } @all_numbers;
my $contains_negative = @negatives;
~~~

You first used `grep` to get all negatives, and then you forced the array
`@negatives` into a scalar and we know that when you force an array into a
scalar it will store the length of that array (do we know that? Well, now we do). We then have that`$contains_negative` contains
a `0` or strictly positive number (in the example, it will contain a positive
number as `@negatives` has 2 elements). We can then use this in a condition:

~~~perl
if ($contains_negative) {
  # stuff
}
~~~

Indeed, since any non-zero positive number is considered true, this condition
will be true if there was _any_ negative number.

Besides being slightly involved, this also not as efficient as it could be:
`grep` collects _all_ negative numbers and we are interested in whether there's
at least `1` negative number. In other words, we'd want to short-circuit this.
We have exactly that functionality in the core module `List::Util` with the
function [`any`](https://perldoc.perl.org/List/Util.html#any):

~~~perl
use List::Util qw(any);

if ( any { $_ < 0 } @all_numbers ) {
  # stuff
}
~~~

You see that `any { $_ < 0 } @all_numbers` returns true if the condition `$_ <
0` is true for _any_ of the numbers in `@all_numbers`.

I sprung something else on you (you're welcome):

~~~perl
use List::Util qw(any);
~~~

You're used to such inclusions of modules/packages/languages (modules in `perl`
parlance) in other languages (Java has import). So `use` announces _I'm making stuff available to use from the
module `List::Util`_. But what with `qw(any)`?

Well, I did not tell you yet. `any` is a function/subroutine (`subroutine` in
`perl`) defined in that `List::Util` module, so we're indicating that we'd like
to import `any` from `List::Util`. But what about `qw`? You are not very patient. But OK, you essentially
want to indicate what functions you'd want to include, so you could write a
literal list of strings: `("any")`. And if you want also the subroutine
`first`:

~~~perl
use List::Util ("any", "first");
~~~

`perl` programmers find double quotes and commans annoying because why not, so you can write this as:

~~~perl
use List::Util qw(any first);
~~~

where `qw` signifies, _hey, these are quoted words_. Or something like that.

We already mentioned `first`: use `first` when rather than just `true`
if there is an element in a list satisfying the condition like `any` does, you'd like to see
that first element that matches the condition:

~~~perl
my @all_numbers = (9, -7, -6, 5, 4);
my $first_negative = first { $_ < 0 } @all_numbers;
~~~

# Looping

Besides the usual C-style [`for` syntax](https://perldoc.perl.org/perlsyn.html#For-Loops), I find myself resorting to:

~~~perl
for my $number (@all_numbers) {
  print "el: $number";
}
~~~

Given the above `@all_numbers` this will print: `el: 9 el: -7 el: -6 el: 5 el: 4 `.

The syntax loops through `@all_numbers`, initializing `my $number` with each consecutive number from
`@all_numbers`. Why is there parentheses`( )` around `@all_numbers` in that syntax. That
seems odd. The internet seems to think that the reason is that it's because
[Larry wants
it](https://stackoverflow.com/questions/3650000/what-is-the-purpose-of-the-parentheses-in-perls-foreach-statement).

Let's print only negative numbers:

~~~perl
for my $number (@all_numbers) {
  if ( $number < 0 ) {
    print $number;
  }
}
~~~

Hypothetically speaking, I am an annoying persion, so I ask you to only use the
condition `$number > 0` (testing for positive numbers) but I'd still like you
to print negative numbers, you would come up with:

~~~perl
for my $number (@all_numbers) {
  if ( $number > 0 ) {
    # do nothing
  }
  else {
    print $number;
  }
}
~~~

I'm on a roll so I annoy you even more and ask, _well, I'd like to see that
without an `else`_. You're thinking, which is a great start. If there's a way
to skip the rest of the loop I can just put the `print` as last statement, I
just need to make sure I never reach that last statement for positive numbers.
I'd just need to skip to the _next_ iteration of the loop:

~~~perl
for my $number (@all_numbers) {
  if ( $number > 0 ) {
    next;
  }
  print $number;
}
~~~

You can use `next`. Usually, when using `next` in such a simple case, you'd
like it to more prominent, so you'd use the postfix notation:

~~~perl
for my $number (@all_numbers) {
  next if ( $number > 0 );
  print $number;
}
~~~

For clarity and because you're big on labels, you can label your for-loops when
having such control statements like `next`:

~~~perl
NUMBER:
for my $number (@all_numbers) {
  next NUMBER if ( $number > 0 );
  print $number;
}
~~~

That's often useful when nesting loops (`next`, `next`? What do you mean
`next`? `next NUMBER` ah ok, why didn't you say that right away?)

You can skip the current iteration. Doesn't it feel great to skip? Can I just
leave the party alltogether. Aka, in what is a tired metaphore, exit the loop?
Yes, use [last](https://perldoc.perl.org/functions/last.html).

Let's do another example of a loop: let's construct a new array out of
`@all_numbers` that contains the elements of `@all_numbers` but doubled:

~~~perl
my @doubled_numbers = ();
for my $number (@all_numbers) {
  push @doubled_numbers, 2 * $number;
}
~~~

Great, we initialized a new array `@doubled_numbers` with the empty array `(
)`. We looped through `@all_numbers` and using `push` we added all doubled numbers.
`push` adds numbers from the back as we saw before so order nicely stays
maintained. Is there a problem with this approach?

It's fine, except that, as is usual in most programming languages, the memory
allocated for `@doubled_numbers` potentially has to be re-allocated
we run out of initial memory for `@doubled_numbers`.
This is inefficient. In cases where we're constructing a new _something_ out of
an another _something_ consider using a
[`map`](https://perldoc.perl.org/functions/map.html):

~~~perl
my @doubled_numbers = map { 2 * $_ } @all_numbers;
~~~

As with `grep`, the variable `$_` will be _each element from `@all_numbers`_.
We will take that element and execute the expresssion within `{ }`, and then we
will put the results of all those executions in 1 list. That list is the result
of the `map`. Note that we can generate multiple elements for each element, so
we can increase the size of the list. Say we want to repeat each occurrence of
each element:

~~~perl
my @double_sight = map { $_, $_ } @all_numbers;
~~~

will return a list of 2 elements for each number in `@all_numbers` which we'll
then concatenate. For example, say `@all_numbers` is `(1, 2, 3)`, then
`@double_sight` will be `(1, 1, 2, 2, 3, 3)`. Why will it not be `((1, 1), (2,
2), (3, 3))`: `perl` does not allow such nested lists, so the inner lists will
be implicitly flattened. We could make the list construction in that latter a
bit more explicit by writing:

~~~perl
my @double_sight = map { ($_, $_) } @all_numbers;
~~~

Since the result of a `map` is always an array, we can always store that result
into an array variable. But we also saw that we can initialize a hash using an
array. In other words, something like this:

~~~perl
my %hash = map { $_ => $_ } @something;
~~~

_could_ make sense.

# Subroutines

We talked about data structures and some ways to manipulate them using `perl`'s
built-ins. But of course, you'd want to define your own subroutines that build
on other subroutines that build on...Because you're a builder, a creator, a
maker, an inventor, oh whatever.

In `perl`, we indicate a subroutine by the keyword `sub`. You can define a
function for the doubling that I used in the above `map`:

~~~perl
sub double_it {
  my ($x) = @_;

  return 2 * $x;
}
~~~

The `return 2 * $x` is clear. What is is _new_  at least for this
document, is the `return`. That's working as it works in other programming
languages: it exits from the subroutine and returns the value `2 * $x` to the
caller of the subroutine.

However, where are the arguments to this function? It
_seems_ like `$x` is the argument but why are you extracting this in the
weirdest way possible:

~~~perl
  my ($x) = @_;
~~~

What is happening here? What is wrong with me? Well, you will call `double_it` as you're used to from other programming languages:

~~~perl
my $y = double_it(5);
~~~

The argument list to `double_it` now gets implicitly bound to the special array
variable `@_`. Note that we already saw special variable `$_`, well, this is
another special one, for arrays. 

In this case, we'd have that `@_` would be bound to `(5)`. Ok, cool, so `my
($x) = @_`is at that point the same as `my ($x) = (5)`. The left hand side is
an array literal with a variable `$x` in it, the right hand side is just an
array literal. `perl` matches those 2 for you such `$x` is now `5`. Exactly
what we were hoping for -- at least I was.  This mechanism of matching allows
you to do neat things:

~~~perl
my ($x, $y) = (5);
~~~

`$x` is now `5`, but what happened to `$y`? It's `undef` as you had nothing to match it with. What about:

~~~perl
my ($x) = (5, 6);
~~~

Again, `$x` is `5`, but what happened with `6`? Nothing. It fell on the floor.
Looking back at `double_it` it also means, we could have done `double_it(5, 6)`
and this would have run without complaints. It's just that when doing `my ($x)
= @_` we'd have dropped `6` on the floor and only have assigned `5`.

I'll mention an alternative way to get to the arguments as you'll see that one as well frequently:

~~~perl
my $x = shift;
my $y = shift;
~~~

as an alternative for 

~~~perl
my ($x, $y) = @_;
~~~

You might ask why do I see `shift` and not `shift @_`? Well, `perl` is in the
habit of assuming defaults, in this case the `@_` is assumed and `shift` indeed
stands for `shift @_`.

This might be a cleaner way in case you want to validate `$x` for example,
before continuing with the rest of the arguments. 

To test our knowledge, let's look at this:

~~~perl
my @a = (1, 2);

sub f {
  my @args = @_;
  $args[0] = 3;
}

f(@a);
print "@a\n";
~~~

What will this print? The array will print the original `@a`, namely `1 2`. The
reason is that `@args` is a copy of `@_`, and we only changed the copy.

How can we make it so the original `@a` is indeed changed. Well, we have references for that:

~~~perl
my @a = (1, 2);

sub f {
  my ($args_ref) = @_;
  $args_ref->[0] = 3;
}

f(\@a);
print "@a\n";
~~~

will print `3 2` as the original `@a` is now indeed changed since we passed it by reference.

Talking about references, can I use a reference to a subroutine as an argument to another subroutine?

Take a simple `print` function:

~~~perl
sub print_double {
  my ($x) = @_;
  print $x * 2;
}
~~~

Now say you want to write a function that applies another function to a scalar.
For example a `do_it` function:

~~~perl
sub do_it {
  my ($function_ref, $x) = @_;
  $function_ref->($x);
}

do_it(\&print_double, 3);
~~~

We gave a reference to the function `print_double` to the `do_it` function:
`\&print_double`. And in the `do_it` function, we called the function using the
`->` notation. We could also have called it as follows:

~~~perl
&{$function_ref}($x);
~~~

so using the dereference `{ }`. Generally, the arrow notation is more readable.

# Matching and Substituting

We cannot talk about `perl` without regular expressions but I'll do my utter
best to keep it short. There's a world of pain for you waiting, so let me
introduce some elements. Say you have a string "there is a wolf somewhere". And
you'd like to check whether to contain the word _wolf_ (it does). You could do:

~~~perl
my $test = "there is a wolf somewhere";
if ($test =~ /wolf/) {
  print "there is a wolf somewhere but you already knew that!";
}
~~~

Well that looked easy enough. The meat of this code is in the `if` test: `$test
=~ /wolf/`. With the binding operator `=~` we are saying: I want to check the
pattern on the right of `=~` in the text on the left of `=~`. What is the
pattern? The pattern is between `/`: `/wolf/`. Note that you'll sometimes see
`m/wolf/` so the pattern prefixed with `m`. That's because there's a version
with `s` as well, which stands for _substitute_. Later more on that.

On important concept is _capture groups_. They allow you to refer to the
matched pattern later:

~~~perl
my $test = "there is a Wolf somewhere";
if ($test =~ /([wW]olf)/) {
  my $matched_wolf = $1;
  print "there is a $matched_wolf somewhere but you already knew that!";
}
~~~

Some "fun" stuff is happening here: we used a _character class_ `[wW]` which
stands for a match with either `w` or `W`. And we surrounded `[wW]olf` with
parenthesis like so: `([wW]olf)`. The parenthesis created a capture group which
we referenced later using `$1`. Note that you could have several capture groups
in a pattern, and you can refer to these as `$1`, `$2`, etc. The ordering is
following the order of the parenthesis. For example, if you have
`((stuff)more)`, we'd have `stuffmore` being in `$1` and `stuff` being in `$2`.

What else do you need to know? A lot more. But I'll say that the dot `.` stands
for any character _except_ a newline.

That was for matching, what about substituting? Very very similar. Let's try:

~~~perl
my $test = "there is a Wolf somewhere";
$test =~ s/([wW]olf)/bear/;
print $test;
~~~

will predictably announce to us that _there is a bear somewhere_. We already
mentioned the `s` for `substitute`. The first part of that `s//` construct is
the pattern to replace, the second part is the pattern to replace it with. We
can refer to the capturing groups of the first pattern in the 2nd pattern:

~~~perl
my $test = "there is a wolf somewhere";
$test =~ s/([wW]olf)/bear$1/;
print $test;
~~~

which would lead to `there is a bearwolf somewhere`. At which point, we should
all just leave the building.

# Constants

I know you miss your `private static final` variables, my dear `java`
aficionado. For the rest of the world, constants, how do I declare something as
constant, you can't change it, don't touch it, don't even look at it!?

You have to use a package:

~~~perl
use Readonly;
~~~

And then:

~~~perl
Readonly my $MEANING_OF_LIFE => 42;
~~~

Things to note:

- we use `=>` instead of `=`
- we write `Readonly` before the variable declaration.

The reader (you!) sees of course that this is probably just a subroutine call
`Readonly(my $MEANING_OF_LIFE, 42)`. Maybe it is. Maybe it is.

In any case, try this:

~~~perl
$MEANING_OF_LIFE = 41;
~~~

The compiler will complain with something along the lines of _Invalid
initialization by assignment_, cause it's a READ-ONLY variable!

# Printing Anything

You might end up adding more debugging `print` statements in `perl` than you're
used in other languages. When printing structures, references, hashes, etc, the
following package will be useful:

~~~perl
use Data::Dumper;

my $hash_ref = {a => 1, b => 2};
print Dumper($hash_ref);
~~~

Often the thing you'd like to print is a deeply nested structure. If you want
to limit the levels you'd like to print you can do:

~~~perl
$Data::Dumper::Maxdepth=2;
~~~

# More

We skipped objects and so much more, but this is called _elements of perl_ and
not the _the art of perl_ so I'll refer you these 3 books once more:

- [Learning Perl: Making Easy Things Easy and Hard Things Possible](https://www.goodreads.com/book/show/30413201-learning-perl) by Randal L. Schwartz, Brian D. Foy, Tom Phoenix,
- [Intermediate Perl](https://www.goodreads.com/book/show/209276.Intermediate_Perl) by Randal L. Schwartz, Brian D. Foy, Tom Phoenix,
- [Perl Best Practices: Standards and Styles for Developing Maintainable Code](https://www.goodreads.com/book/show/86379.Perl_Best_Practices) by Damian Conway.

Before doing something yourself, check [CPAN](https://metacpan.org) to see
whether it has been done before.

# Conclusion

I hope the above is enough to get you started with `perl`. If you see errors I
made or if something could use some more clarification, don't hesitate to reach
out at stijn.heymans@gmail.com and I'd be happy to help or to help
find the answer. 

Thanks for reading!


<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/latex.css?">
<!-- Markdeep: --><style class="fallback">body{visibility:hidden}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
